<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="database,PostgreSQL,Concurrency Control,">










<meta name="description" content="概述 并发控制技术，是数据库事务实现的基石，在确保事务隔离性正确的前提下，尽可能提高事务的并发度。 广义上看，并发控制属于事务调度，调度的种类非常多，串行化、可串行化、不可恢复性等等；在这里，我们更多从狭义上来讲调度，指可串行化的调度。 事务的正确性主要体现在ACID特性上，而并发控制主要涉及其中的I即Isolation，即事务隔离性，避免脏读，幻读，写偏斜等读写异常。且满足事务的可恢复性属性。">
<meta name="keywords" content="database,PostgreSQL,Concurrency Control">
<meta property="og:type" content="article">
<meta property="og:title" content="数据库并发控制理论">
<meta property="og:url" content="http://yoursite.com/2022/07/08/database_concurrency_control/index.html">
<meta property="og:site_name" content="Ken&#39;s blog">
<meta property="og:description" content="概述 并发控制技术，是数据库事务实现的基石，在确保事务隔离性正确的前提下，尽可能提高事务的并发度。 广义上看，并发控制属于事务调度，调度的种类非常多，串行化、可串行化、不可恢复性等等；在这里，我们更多从狭义上来讲调度，指可串行化的调度。 事务的正确性主要体现在ACID特性上，而并发控制主要涉及其中的I即Isolation，即事务隔离性，避免脏读，幻读，写偏斜等读写异常。且满足事务的可恢复性属性。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://auto.tancdn.com/v1/images/eyJpZCI6IjU3SDVVUVVBNUxUU01UMk82RzM2TVRJVVgzWVNRRjEwIiwidyI6MzAzLCJoIjoxMzYsImQiOjAsIm10IjoiaW1hZ2UvanBlZyIsImRoIjozNTEwMjQ5NDgzMDUxNzgyNjcyfQ?format=originalOFGHLERTH">
<meta property="og:image" content="https://auto.tancdn.com/v1/images/eyJpZCI6IkFKQkJLTEJIN1VINk1IV1lZMzdSQVNGTjZFM0tSSjExIiwidyI6NjAwLCJoIjo0MDAsImQiOjAsIm10IjoiaW1hZ2UvanBlZyIsImRoIjo3MDEwMjE5NDQ1MTQ3NDkyNzY5fQ?format=originalOFGHLERTH">
<meta property="og:image" content="https://auto.tancdn.com/v1/images/eyJpZCI6IldUUFRRNFJEUkJFMzNISUxES1dCS1VKTFRLS0xaVjEwIiwidyI6OTgzLCJoIjozNDgsImQiOjAsIm10IjoiaW1hZ2UvanBlZyIsImRoIjoxNDc0Mzg5NzQzMTMxOTUzOTExN30?format=originalOFGHLERTH">
<meta property="og:image" content="https://auto.tancdn.com/v1/images/eyJpZCI6IkFUVVM0RkZIRkJISDJYNkhCNE1HSUUzRlVFS1JMRjExIiwidyI6NjgwLCJoIjo0NTIsImQiOjAsIm10IjoiaW1hZ2UvanBlZyIsImRoIjoxNjE4NDE3ODE2MjYwMjY1MzQxNH0?format=originalOFGHLERTH">
<meta property="og:image" content="https://auto.tancdn.com/v1/images/eyJpZCI6IlU1WDVFTzNDVElETVdITEpBVVZBSkpNNzdNQ0haNzEwIiwidyI6Njc4LCJoIjo0MzIsImQiOjAsIm10IjoiaW1hZ2UvanBlZyIsImRoIjoxNjczNzg1NzMwODg0NDQ3NTU3NX0?format=originalOFGHLERTH">
<meta property="og:image" content="https://auto.tancdn.com/v1/images/eyJpZCI6IjRTVExKUUdLSEhRUk1NQ0cyQUtLU0JBQU9MREgyTjEwIiwidyI6OTUwLCJoIjoyODAsImQiOjAsIm10IjoiaW1hZ2UvanBlZyIsImRoIjoxNDc2NDczODY5MDE2MjY0ODA2NH0?format=originalOFGHLERTH">
<meta property="og:image" content="https://auto.tancdn.com/v1/images/eyJpZCI6IklQSUM1WkxMRTRKWTdNQ0JISDVONFRDMkZBTkJHUjExIiwidyI6MTM3NiwiaCI6NDMzLCJkIjowLCJtdCI6ImltYWdlL2pwZWciLCJkaCI6MTQxNTMxMTA0NTQzMjE3MjIzOTN9?format=originalOFGHLERTH">
<meta property="og:image" content="https://auto.tancdn.com/v1/images/eyJpZCI6IkVSN1ZFTVI1R1NHN0NJQ0ZRRlM1NkhEVkRCVU9TVDEwIiwidyI6NTc2LCJoIjoyMDcsImQiOjAsIm10IjoiaW1hZ2UvanBlZyIsImRoIjoxMzI4NzE4NjQ3MjE2ODQ5OTIxfQ?format=originalOFGHLERTH">
<meta property="og:image" content="https://auto.tancdn.com/v1/images/eyJpZCI6Ilg2SkZIQ0NCNlNLNFZSSDJMR041RlRQS1BRV0pNNTExIiwidyI6NTc0LCJoIjo0MzgsImQiOjAsIm10IjoiaW1hZ2UvanBlZyIsImRoIjoxMDIzNjAwMzAyNTEzMzU5NzIzMn0?format=originalOFGHLERTH">
<meta property="og:image" content="https://auto.tancdn.com/v1/images/eyJpZCI6IkRLVVlGWFdUVDdWSFpZQko3NkVaUlNBTUhaUUhLWDEwIiwidyI6NjcyLCJoIjo0NzUsImQiOjAsIm10IjoiaW1hZ2UvanBlZyIsImRoIjoxNTA1MDEzOTkyNjgzMzA2MTU3Mn0?format=originalOFGHLERTH">
<meta property="og:updated_time" content="2022-07-08T05:41:44.686Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="数据库并发控制理论">
<meta name="twitter:description" content="概述 并发控制技术，是数据库事务实现的基石，在确保事务隔离性正确的前提下，尽可能提高事务的并发度。 广义上看，并发控制属于事务调度，调度的种类非常多，串行化、可串行化、不可恢复性等等；在这里，我们更多从狭义上来讲调度，指可串行化的调度。 事务的正确性主要体现在ACID特性上，而并发控制主要涉及其中的I即Isolation，即事务隔离性，避免脏读，幻读，写偏斜等读写异常。且满足事务的可恢复性属性。">
<meta name="twitter:image" content="https://auto.tancdn.com/v1/images/eyJpZCI6IjU3SDVVUVVBNUxUU01UMk82RzM2TVRJVVgzWVNRRjEwIiwidyI6MzAzLCJoIjoxMzYsImQiOjAsIm10IjoiaW1hZ2UvanBlZyIsImRoIjozNTEwMjQ5NDgzMDUxNzgyNjcyfQ?format=originalOFGHLERTH">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2022/07/08/database_concurrency_control/">





  <title>数据库并发控制理论 | Ken's blog</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?46ee37f7c4a6bed681519fb13fb55b02";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ken's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description"></h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/07/08/database_concurrency_control/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ken">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ken's blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">数据库并发控制理论</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-07-08T00:00:00+08:00">
                2022-07-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/2022/" itemprop="url" rel="index">
                    <span itemprop="name">2022</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2022/07/08/database_concurrency_control/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2022/07/08/database_concurrency_control/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>浏览
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>次
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="概述">概述</h1>
<p>并发控制技术，是数据库事务实现的基石，在确保事务隔离性正确的前提下，尽可能提高事务的并发度。</p>
<p>广义上看，并发控制属于事务调度，调度的种类非常多，串行化、可串行化、不可恢复性等等；在这里，我们更多从狭义上来讲调度，指可串行化的调度。</p>
<p>事务的正确性主要体现在ACID特性上，而并发控制主要涉及其中的I即Isolation，即事务隔离性，避免脏读，幻读，写偏斜等读写异常。且满足事务的可恢复性属性。</p>
<p>为了提高事务的并发度，则ISO定义了几种不同的隔离级别，让数据库在不同隔离级别下提供不同的正确性保证，在并发度和正确性之间取舍。</p>
<p>本文主要描述关系数据库的并发控制理论，不会过多涉及MySQL等数据库的实现细节，避免局限于这些数据库的具体实现。</p>
<h1 id="理论">理论</h1>
<h2 id="实现方向">实现方向</h2>
<p>并发控制技术，从检测是否存在冲突的角度看，包括乐观的，悲观的，处于两者之间的半乐观方法</p>
<ul>
<li>乐观（optimistic concurrency control，OCC）：从一开始，每一项操作都允许进行，但在事务提交的时刻，进行隔离性和完整性约束的检查，如果有违反则事务被回滚</li>
<li>悲观（pessimistic concurrency control，PCC）：从一开始，即检查每一项操作是否会违反隔离性和完整性约束，如果可能违反，则阻塞这样的操作</li>
</ul>
<p>从控制冲突的时机看，包括基于锁的，基于时间的，基于提交顺序的，基于串行化图测试检验的各种方法，还有基于多版本并发控制的技术。</p>
<p>串行化的含义是完全限制并发；可串行化是在能保证一致性的情况下，允许某些并发的操作被执行；以提高数据库整体的运行效率。数据确保事务特性的前提下，还要在不同的调度下能满足事务的属性：可串行化(serializability)，可恢复性(recoverability)。然而不是所有的调度都是满足事务属性的，有的调度可以牺牲可串行化或者可恢复性，以获得更高的并发度。</p>
<h2 id="可串行化">可串行化</h2>
<p><strong>Serial schedule</strong><br>
要想事务不互相影响，那么最简单的方式就是让事务的执行是串行的，不交叉执行，称这种执行调度为serial schedule，串行化调度（也有翻译称序列化调度的）。</p>
<p>然而多个事务在这种调度下是无法并发执行的，那么执行效率就非常低下。数据库要能够并发执行，就不能使用串行化的调度策略，但是又要保证性能和隔离性，也就是<strong><em>等价于</em></strong>serial schedule，那么我们称这种调度策略为serializable schedule，可串行化调度。</p>
<p>那么，如何理解"等价于"呢？也就是事务执行的正确性？</p>
<p>数据库系统中，将"等价"分为三种</p>
<ul>
<li>final state equivalence终态等价</li>
<li>view equivalence视图等价</li>
<li>conflict equivalence冲突等价</li>
</ul>
<p>所以按照这三种等价于serial schedule的调度也分为三种：</p>
<ul>
<li>final state serializability终态串行化</li>
<li>view serializability视图串行化</li>
<li>conflict serializability冲突串行化</li>
</ul>
<h3 id="终态可串行化">终态可串行化</h3>
<p>终态可串行化，final state serializability，又称为result equivalence serializability。</p>
<p>如果两个调度的执行结果一样，则认为两个调度是final state equivalent的，如果调度的执行结果和serial schedule一样，则是final state serializability的。就像两个函数，输入的参数一样，如果返回的结果也一样的话，则两者是final state equivalent的。其忽略了如何实现函数的内部结构，把函数当成黑盒了。</p>
<p>那如何判断两个调度是否为final state equivalent的呢？把两个调度各自执行一遍？显然这是不可能的，也有研究将调度操作转换成有向图，但要确保正确性就需要将调度的所有操作（读、写和控制流）都加入到有向图中，那和执行一遍调度几乎没有什么区别。<br>
所以final state serializability对于现实工程实现并没有什么指导意义。</p>
<h3 id="冲突可串行化">冲突可串行化</h3>
<p>冲突可串行化， conflict serializability</p>
<p><strong>冲突行为</strong></p>
<p>当下面三种条件都满足时，我们将两个操作视为冲突</p>
<ul>
<li>两个操作属于不同的事务</li>
<li>两个操作访问和处理的数据集有重叠</li>
<li>至少有一个操作的是写操作</li>
</ul>
<p>从定义中，我们可以将不同事务并发操作同一数据产生的冲突分为三类</p>
<ul>
<li>R-W冲突：事务Ti读取了数据O但还没提交，事务Tj修改了O，（造成不可重复读）</li>
<li>W-R冲突：事务Ti修改了数据O但还没提交，事务Tj读取了O，（造成读未提交）</li>
<li>W-W冲突：事务Ti修改了数据O但还没提交，事务Tj也修改了O，（造成丢失更新）</li>
</ul>
<p><strong>conflict equivalence</strong></p>
<p>如果某个调度能通过交换非冲突操作来将调度转换成serial schedule，则两者是conflict equivalent的，则称这种调度为conflict serializability。</p>
<p>例如： 事务的执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T1: R(A), W(A), R(B), W(B)</span><br><span class="line">T2: R(A), W(A), R(B), W(B)</span><br></pre></td></tr></table></figure>
<p>可能的serial schedules：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// T1-&gt;T2</span><br><span class="line">T1          T2</span><br><span class="line">R1(A)</span><br><span class="line">W1(A)</span><br><span class="line">R1(B)</span><br><span class="line">W1(B)</span><br><span class="line">            R2(A)</span><br><span class="line">            W2(A)</span><br><span class="line">            R2(B)</span><br><span class="line">            W2(B)</span><br><span class="line">-------------------------</span><br><span class="line">// T2-&gt;T1</span><br><span class="line">            R2(A)</span><br><span class="line">            W2(A)</span><br><span class="line">            R2(B)</span><br><span class="line">            W2(B)</span><br><span class="line">R1(A)</span><br><span class="line">W1(A)</span><br><span class="line">R1(B)</span><br><span class="line">W1(B)</span><br></pre></td></tr></table></figure>
<p>现在我们通过交换非冲突操作来达到conflict serializability</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// S1 </span><br><span class="line">T1        T2</span><br><span class="line">R(A)</span><br><span class="line">W(A)</span><br><span class="line">          R(A)      &lt;---</span><br><span class="line">          W(A)      &lt;------</span><br><span class="line">R(B)                &lt;---   </span><br><span class="line">W(B)                &lt;------</span><br><span class="line">          R(B)</span><br><span class="line">          W(B)</span><br></pre></td></tr></table></figure>
<p>T1的R(B), W(B) 和 T2的R(A), W(A)是非冲突的，所以可以将他们进行交换。</p>
<p>通过两次交换，可以将S1转换成 T1-&gt;T2的serial schedule，所以S1是 conflict serializability。</p>
<p>再看看不是conflict serializability的例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// S2 </span><br><span class="line">T1         T2</span><br><span class="line">           R(A)</span><br><span class="line">           W(A)</span><br><span class="line">R(A)</span><br><span class="line">W(A)</span><br><span class="line">R(B)</span><br><span class="line">W(B)</span><br><span class="line">           R(B)</span><br><span class="line">           W(B)</span><br></pre></td></tr></table></figure>
<p>可以看出，T1对A和B的操作，都没有办法交换到T2的前面或后面。所以S2不是conflict serializability。</p>
<p><strong>优先图检测冲突可串行化</strong></p>
<p>然而对两三个事务进行判断conflict serializability相对还比较简单，但是对很多事务要进行判断却是非常困难的，那要如何检测呢？</p>
<p>我们以事务为单位，使用事务之间的冲突行为定义事务执行的先后顺序。<br>
如Ti的Ri(A)与Tj的Wj(A)冲突，而<code>Ri(A)&lt;Wj(A)</code>，所以Ti就要先于Tj执行，所以就可以使用优先图来检测冲突可串行化。而如果优先图(precedence graph)没有环，则说明调度是冲突可串行化的。因为如果Ti需要在Tj前执行，又有Tj需要在Ti前执行，显然这是矛盾的，所以存在环则不是冲突可串行化的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">T1          T2</span><br><span class="line">R(A)</span><br><span class="line">W(A)</span><br><span class="line">            R(A)</span><br><span class="line">            R(B)</span><br><span class="line">R(B)</span><br><span class="line">W(B)</span><br></pre></td></tr></table></figure>
<p>可以看出，T1先写了A，T2后读了A，所以wr冲突，T1优先于T2；而T2读取了B，后面T1又修改了B，那么rw冲突，T2优先于T1。所以形成了环，说明不是冲突可串行化的。</p>
<figure>
<img src="https://auto.tancdn.com/v1/images/eyJpZCI6IjU3SDVVUVVBNUxUU01UMk82RzM2TVRJVVgzWVNRRjEwIiwidyI6MzAzLCJoIjoxMzYsImQiOjAsIm10IjoiaW1hZ2UvanBlZyIsImRoIjozNTEwMjQ5NDgzMDUxNzgyNjcyfQ?format=originalOFGHLERTH" alt="image"><figcaption aria-hidden="true">image</figcaption>
</figure>
<blockquote>
<p>实际上，这只是一种研究的理论方向，从现有主流并发控制技术来看，基于锁的并发控制实现，将冲突操作通过锁的方式来互斥，就这天然的阻止了冲突操作中环的形成。</p>
</blockquote>
<h3 id="视图可串行化">视图可串行化</h3>
<p>视图可串行化, view serializability。</p>
<p>《concurrency control and recovery in database systems》定义两个schedule S1和 S2是 view-equivalent的，只有满足：</p>
<ul>
<li>S1和S2的transactions相同。如果在S1中，T1最先读取A，则在S2中，也必须是T1最先读取A。</li>
<li>读写依赖：对于S1 和 S2中的Ti和Tj，如果在S1中，Oi 从 Oj中读取，那么在S2中，Oi也从Oj中读取。Tj先写了O，而Ti后读取O，<code>Wj(O) &lt; Ri(O)</code></li>
<li>最后写(final write)：如果在S1中Ti最后写入O，那么S2中也是Ti最后写入O。</li>
</ul>
<p><strong>读写</strong></p>
<p>两种调度对同一对象的读写顺序必须一致，其实也就是其冲突操作是要一致的，和conflict equivelance一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">        S1                      S2</span><br><span class="line">-------------------       ----------------</span><br><span class="line">T1     T2     T3          T1    T2    T3                   </span><br><span class="line">W(A)                      W(A)       </span><br><span class="line">       W(A)                            R(A)</span><br><span class="line">              R(A)              W(A)</span><br></pre></td></tr></table></figure>
<p>如上面两个调度就不是view-equivalent的，S1中，T3读取A的值是由T2更新的，而S2中T3读取的A是由T1更新了。</p>
<p><strong>最后写</strong></p>
<p>如果S1中事务Ti最后修改了数据O，则在S2最后修改数据O的也是事务Ti。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">        S1                      S2</span><br><span class="line">-------------------       ----------------</span><br><span class="line"> T1       T2                T1       T2            </span><br><span class="line"> R(A)                       R(A)</span><br><span class="line">         W(A)               W(A)</span><br><span class="line"> W(A)                                W(A)</span><br></pre></td></tr></table></figure>
<p>如上，S1和S2不是view-equivalence的，因为S1最后写A的是T1，而S2中最后写A的是T2。</p>
<p>从上面可以看出，view-equivalence和conflict-equivalence不一样的是，view-equivalence增加了final write的条件，这样相对于conflict-equivalence，反而约束宽松了。</p>
<p>如下调度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T1       T2       T3</span><br><span class="line">R(A)</span><br><span class="line">         W(A)</span><br><span class="line">W(A)</span><br><span class="line">                  W(A)</span><br></pre></td></tr></table></figure>
<p>由于此调度的优先图存在环(T1的R(A)或W(A)与W(A)也无法交换)，所以调度不是conflict serializability的。<br>
但T3的W(A)在最后写（盲写blind write），所以和serial schedule(T1-&gt;T2-&gt;T3) 是view-equivalent的。<br>
可以看出，优先图存在一定的局限性，虽然调度不是conflict serializability的，却可能是view serializability的，其实conflict serializability是view serializability的一个子集。 但现在仍没有一种高效的方法来判断调度是否为view serializability的，所以view serializability没有实用价值。</p>
<hr>
<h2 id="可恢复性">可恢复性</h2>
<p>可恢复性的定义如下：</p>
<blockquote>
<p>Recoverability means that committed transactions have not read data written by aborted transactions（whose effects do not exist in the resulting database states）。</p>
</blockquote>
<p>即：已经提交的事务没有读过被中止的事务写的数据。否则脏读异常发生，导致数据不一致。</p>
<p>其实可恢复性对事务回滚进行了定义，所以和可串行性一起保证事务正确执行</p>
<ul>
<li>可串行性：当所有事务提交时，调度执行的顺序和串行执行的结果一样</li>
<li>可恢复性：当有事务回滚时，不会存在由于脏读导致数据不一致。</li>
</ul>
<p>下面调度，是可串行化的，T1在T2前执行，但T2先提交，所以不满足可恢复性。 可以想象如果发生崩溃，T2的提交记录到达磁盘，而T1没有到达，那么恢复后，T2都处于提交状态，而T1会回滚。C指Commit。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">T1          T2</span><br><span class="line">W(A)</span><br><span class="line">W(B)</span><br><span class="line">            W(A)</span><br><span class="line">            R(B)</span><br><span class="line">            C</span><br><span class="line">C</span><br></pre></td></tr></table></figure>
<h3 id="级联回滚">级联回滚</h3>
<p>由于允许脏读（读取还未提交事务修改的数据），所以如果一个更新某些数据的事务回滚，则其他读取了这些数据的事务也会导致回滚。</p>
<p>如下，T2读取了T1更新的值，T3读取了T2更新的值，那么T1回滚，为了避免数据不一致，所以T2和T3必须回滚。A指Abort。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">T1        T2         T3</span><br><span class="line">R(X)</span><br><span class="line">W(X)</span><br><span class="line">          R(X)</span><br><span class="line">          W(X)</span><br><span class="line">          </span><br><span class="line">                    R(X)</span><br><span class="line">                    W(X)</span><br><span class="line">A(X)</span><br><span class="line">          A(X)</span><br><span class="line">                    A(X)</span><br></pre></td></tr></table></figure>
<p>所以级联回滚对性能影响很大，应该尽量避免。</p>
<h3 id="避免级联回滚">避免级联回滚</h3>
<p>cascadeless schedule，又称为avoiding cascading aborts (ACA)，避免级联回滚。</p>
<p>其定义如下：</p>
<blockquote>
<p>A strategy to prevent cascading aborts is to disallow a transaction from reading uncommitted changes from another transaction in the same schedule.</p>
</blockquote>
<p>既然脏读导致了级联回滚，那么不允许脏读就可以避免级联回滚了。也就是只允许读取已经提交事务修改的数据。</p>
<p>如以下调度，必须等到T1完成提交，T2才能读取A</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">T1            T2</span><br><span class="line">R(A)</span><br><span class="line">W(A)</span><br><span class="line">C</span><br><span class="line">              R(A)</span><br><span class="line">              W(A)</span><br><span class="line">              C</span><br></pre></td></tr></table></figure>
<h3 id="严格性">严格性</h3>
<p>严格性strictness</p>
<blockquote>
<p>A schedule is strict - has the strictness property - if for any two transactions T1, T2, if a write operation of T1 precedes a conflicting operation of T2 (either read or write), then the commit or abort event of T1 also precedes that conflicting operation of T2.</p>
</blockquote>
<p>避免级联回滚虽然不允许脏读，但是忽略了一个问题，就是丢失更新。不允许读取未提交事务修改的数据，没有不允许修改未提交事务修改的数据。所以严格性就对此做了限制，即不允许读取或修改未提交事务修改过的数据。</p>
<p>如以下调度就是ACA的，但不是strictness的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">T1            T2</span><br><span class="line">R(A)</span><br><span class="line">W(A)</span><br><span class="line">              W(A)   // 修改了T1修改的A</span><br><span class="line">C</span><br></pre></td></tr></table></figure>
<p><strong>为什么不允许写未提交事务修改的数据呢？</strong></p>
<p>我们可以想象以下场景：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">T1                  T2</span><br><span class="line">W(x, 1); </span><br><span class="line">W(y, 11); </span><br><span class="line">                   W(y, 22); </span><br><span class="line">A; </span><br><span class="line">                   R(x); </span><br><span class="line">                   A</span><br></pre></td></tr></table></figure>
<p>T1 abort时，将y从11改成1(称为before image前像)， 但当T2 abort时，T2其执行W2(y, 22)的前像是11，T2如果简单回滚到前像，则会出错。 这样就增加了回滚复杂度。</p>
<h2 id="属性关系">属性关系</h2>
<p>我们引用维基百科的一张图来描述属性之间的关系</p>
<figure>
<img src="https://auto.tancdn.com/v1/images/eyJpZCI6IkFKQkJLTEJIN1VINk1IV1lZMzdSQVNGTjZFM0tSSjExIiwidyI6NjAwLCJoIjo0MDAsImQiOjAsIm10IjoiaW1hZ2UvanBlZyIsImRoIjo3MDEwMjE5NDQ1MTQ3NDkyNzY5fQ?format=originalOFGHLERTH" alt="image"><figcaption aria-hidden="true">image</figcaption>
</figure>
<p>从串行化的角度看，严格程度的次序(前松后紧)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all schedules -&gt; view serializable -&gt; conflict serializable -&gt; serial</span><br></pre></td></tr></table></figure>
<p>从可恢复性的角度看，严格程度的次序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">all schedules -&gt; recoverable -&gt; avoids cascading aborts -&gt; strictness -&gt; serial</span><br></pre></td></tr></table></figure>
<h1 id="基于锁的并发控制">基于锁的并发控制</h1>
<p>基于锁的并发控制相关知识有很多，如</p>
<ul>
<li>锁的粒度，tuple，page，table等等</li>
<li>锁的类型：排他锁，共享锁，意向锁</li>
<li>锁的合并与升级</li>
<li>锁的管理：死锁检测、预防等</li>
</ul>
<p>不打算在本文中来聊这些技术实现，因为涉及到的内容实在太多了， 如死锁预防，相关手段就非常多，每一种都是一个细化的研究方向。<br>
本文只关注如何通过锁来实现可串行化的并发控制，至于其他工程优化手段等，以后再写专门的文章来讨论吧。</p>
<p>如果锁是普通的加锁与解锁，我们看看会有什么问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// A = 20, B = 20</span><br><span class="line">T1                 T2</span><br><span class="line">Lock(A)           </span><br><span class="line">A=A-10</span><br><span class="line">Unlock(A)</span><br><span class="line">               Lock(B)</span><br><span class="line">               Read(B)</span><br><span class="line">               Unlock(B)</span><br><span class="line">               </span><br><span class="line">               Lock(A)</span><br><span class="line">               Read(A)</span><br><span class="line">               Unlock(A)</span><br><span class="line">               echo A+B // 30</span><br><span class="line">Lock(B)</span><br><span class="line">B=B+10</span><br><span class="line">Unlock(B)</span><br></pre></td></tr></table></figure>
<p>如果是序列化执行，不管T1先执行还是T2先执行，那么T2得出的<code>A+B</code>结果都是40。<br>
而此调度会造成T2的结果是30，显然不是可序列化的。</p>
<h2 id="pl">2PL</h2>
<p>2PL，two-phase locking，两阶段封锁协议。</p>
<p>为了确保可串行化，所以引入两阶段锁。</p>
<p>将事务的获取锁和释放锁分成了增长(growing)和缩减(shrinking)两个不同的阶段</p>
<ul>
<li>增长阶段：每个事务请求所有需要的锁资源，此阶段不允许释放任何锁</li>
<li>缩减阶段：事务进入释放锁的阶段，不允许再对资源进行加锁</li>
</ul>
<p>2PL是能够保证冲突可串行化的，所以能满足可串行化。 可以看到下面调度的事务执行，结果和串行化执行结果是一样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// A = 20, B = 20</span><br><span class="line">T1                 T2</span><br><span class="line">Begin          Begin</span><br><span class="line">Lock(A)    </span><br><span class="line">Lock(B)</span><br><span class="line">A=A-10</span><br><span class="line">B=B+10</span><br><span class="line"></span><br><span class="line">Unlock(A)</span><br><span class="line">Unlock(B)</span><br><span class="line">               Lock(B)</span><br><span class="line">               Read(B)</span><br><span class="line">               </span><br><span class="line">               Lock(A)</span><br><span class="line">               Lock(Z)</span><br><span class="line">               Read(A)</span><br><span class="line">               </span><br><span class="line">               Z=A+B     // 40</span><br><span class="line">               Unlock(B)</span><br><span class="line">               Unlock(A)</span><br><span class="line">             </span><br><span class="line">commit</span><br><span class="line">               commit</span><br></pre></td></tr></table></figure>
<p>但是如果T1的回滚了，则导致T2也必须回滚，不然就产生脏读。<br>
所以如上所说，虽然保证了可串行化，但不满足可恢复性，故而不能避免级联回滚。</p>
<h2 id="s2pl">S2PL</h2>
<p>为了避免上面的问题，所以很多现代数据库使用S2PL或SS2PL来实现并发控制。</p>
<p>strict two-phase locking严格两阶段封锁。</p>
<p>除了封锁满足两阶段封锁条件之外，还要求持有的排它锁必须在事务提交后才能释放。这个要求保证未提交事务所写的任何数据在该事务提交之前均以排它方式加锁，从而能够避免级联回滚。</p>
<p>遵循严格封锁调度有两个特性</p>
<ul>
<li>符合ACA的也符合strictness，因为由于锁的存在无法读取或修改其他未提交事务修改的值</li>
<li>是可串行化的</li>
</ul>
<p>可以看到下面的例子，只有当T1 Commit后，才会释放B的写锁， 所以T2要等到T1 Commit后，才能获取到B的读锁；假设T1回滚，也不会造成T2回滚，这样就避免了级联回滚了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// A = 20, B = 20</span><br><span class="line">T1                 T2</span><br><span class="line">Begin             Begin</span><br><span class="line">R-Lock(A)    </span><br><span class="line">W-Lock(B)        R-Lock(A)</span><br><span class="line">                 Read(A)</span><br><span class="line">B=A+10</span><br><span class="line"></span><br><span class="line">R-Unlock(A)</span><br><span class="line">Commit</span><br><span class="line">W-Unlock(B)</span><br><span class="line">                 R-Lock(B)</span><br><span class="line">                 Read(B)</span><br><span class="line">               </span><br><span class="line">                 W-Lock(Z)</span><br><span class="line">                 </span><br><span class="line">                 Z=A+B    </span><br><span class="line">                 R-Unlock(B)</span><br><span class="line">                 R-Unlock(A)</span><br><span class="line">    </span><br><span class="line">                 Commit   </span><br><span class="line">                 W-Unlock(Z)</span><br></pre></td></tr></table></figure>
<h2 id="ss2pl">SS2PL</h2>
<p>强严格两阶段锁，strong strict two-phase locking，也称为rigorous 2PL。</p>
<p>除了封锁满足两阶段之外，还要求事务提交之前不得释放任何锁。</p>
<p>SS2PL降低了并发度，但带来的好处是</p>
<ul>
<li>不像S2PL需要跟踪每个事务的锁的阶段，整个事务提交前都是两阶段增长阶段，提交后才是缩减阶段，这样实现起来就很简单了</li>
<li>且保证了提交顺序，CO(commitment ordering)，以后再聊CO</li>
</ul>
<h2 id="隔离级别">隔离级别</h2>
<p>我们再看看如何基于锁并发控制实现不同的隔离级别</p>
<table>
<thead>
<tr class="header">
<th>隔离级别</th>
<th>读操作</th>
<th>写操作</th>
<th>范围操作</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>读未提交</td>
<td>S</td>
<td>S</td>
<td>S</td>
</tr>
<tr class="even">
<td>读已提交</td>
<td>S</td>
<td>C</td>
<td>S</td>
</tr>
<tr class="odd">
<td>可重复读</td>
<td>C</td>
<td>C</td>
<td>S</td>
</tr>
<tr class="even">
<td>可串行化</td>
<td>S</td>
<td>S</td>
<td>S</td>
</tr>
</tbody>
</table>
<ul>
<li>S表示操作前加锁，操作后释放锁<br>
</li>
<li>C表示操作前加锁，提交后释放锁</li>
</ul>
<p>通过这些锁的策略，则可以通过锁来实现各种隔离级别。</p>
<p>例如读已提交：写操作在提交后再释放，这样就阻塞读请求了，从而避免读到未提交的数据。</p>
<h1 id="多版本并发控制">多版本并发控制</h1>
<p>multi-version concurrency control (MVCC) 是一个比较宽泛的概念，不仅仅指并发控制。<br>
核心思想是对每个对象的修改都会产生一个新的版本，可以读取任意存在的版本，对所有对象进行版本的管理控制。<br>
这样的好处是修改操作和读历史版本的读操作各自不影响对方，可以并行操作。</p>
<p>对于数据库操作冲突来说，读写冲突（快照）是可以通过MVCC机制来避免的，而写写冲突则可以通过加锁的方式来避免并发修改，从而保证正确性。</p>
<p>设计MVCC的几个主要的考虑方向:</p>
<ul>
<li>版本存储：version storage</li>
<li>垃圾回收：garbage collection</li>
<li>索引管理：index management</li>
</ul>
<h2 id="版本存储">版本存储</h2>
<p>数据库中更新一条记录，就会对这条记录产生一个新的版本，通过指针将不同的版本记录链接起来，组成版本链。这样，数据库就可以通过版本链找到不同版本的记录。</p>
<p>版本的组织方式有以下几种</p>
<ul>
<li>append-only storage追加方式：新版本直接追加写入到同一个表空间中</li>
<li>time-travel storage时间线方式：老版本单独存储在一个表空间中</li>
<li>delta storage增量存储方式：只存储修改部分的数据，而不是整个元组</li>
</ul>
<blockquote>
<p>元组（tuple）：指的是数据库存储引擎中的一条有版本信息的记录。</p>
</blockquote>
<h3 id="追加方式">追加方式</h3>
<p>append-only storage</p>
<p>版本链的指向顺序有两种方式</p>
<ul>
<li>老版本的指针指向新版本记录 oldest-to-newest(O2N)</li>
<li>新版本的指针指向老版本记录 newest-to-oldest(N2O)</li>
</ul>
<p>O2N<br>
生成新版本时，将老版本的指针指向新版本，所以访问这个新记录，需要遍历老记录，这样就会产生读放大，且生成新纪录时需要更新老记录的指针。</p>
<p>N2O<br>
生成新版本时，将新版本的指针指向老版本，所以访问某个版本的记录时，需要从新记录开始遍历到指定版本。</p>
<p><img src="https://auto.tancdn.com/v1/images/eyJpZCI6IldUUFRRNFJEUkJFMzNISUxES1dCS1VKTFRLS0xaVjEwIiwidyI6OTgzLCJoIjozNDgsImQiOjAsIm10IjoiaW1hZ2UvanBlZyIsImRoIjoxNDc0Mzg5NzQzMTMxOTUzOTExN30?format=originalOFGHLERTH" alt="image"> 图来源于论文：《An Empirical Evaluation of In-Memory Multi-Version Concurrency Control》</p>
<h3 id="时间线方式">时间线方式</h3>
<p>time-travel storage</p>
<p>将老版本直接copy到time-travel表，新版本写入主表，新版本指向老版本。<br>
索引指向主表即可，通过主表中最新版本的指针去遍历老版本。<br>
time-travel也是append-only的存储方式，只是新老版本在不同的表空间中。这种方式有利于回收老版本记录，但同时产生了写放大。</p>
<figure>
<img src="https://auto.tancdn.com/v1/images/eyJpZCI6IkFUVVM0RkZIRkJISDJYNkhCNE1HSUUzRlVFS1JMRjExIiwidyI6NjgwLCJoIjo0NTIsImQiOjAsIm10IjoiaW1hZ2UvanBlZyIsImRoIjoxNjE4NDE3ODE2MjYwMjY1MzQxNH0?format=originalOFGHLERTH" alt="image"><figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="增量存储方式">增量存储方式</h3>
<p>delta storage</p>
<p>只存储修改部分的数据，而不是整个tuple。由于不需要copy整个tuple，所以更快速。 而读取的时候需要组装数据，所以更慢。</p>
<figure>
<img src="https://auto.tancdn.com/v1/images/eyJpZCI6IlU1WDVFTzNDVElETVdITEpBVVZBSkpNNzdNQ0haNzEwIiwidyI6Njc4LCJoIjo0MzIsImQiOjAsIm10IjoiaW1hZ2UvanBlZyIsImRoIjoxNjczNzg1NzMwODg0NDQ3NTU3NX0?format=originalOFGHLERTH" alt="image"><figcaption aria-hidden="true">image</figcaption>
</figure>
<h2 id="垃圾回收">垃圾回收</h2>
<p>当所有运行中的事务都不会再读取到一条记录的某个版本时，则这个版本是可回收的。<br>
如所有运行的事务中，最小可见的版本号是11，如果一条记录的最新版本号是6，那么这条记录的小于6的版本都是可以回收的。</p>
<p>一般有两种回收方式</p>
<ul>
<li>tuple-level元组级别：以元组为粒度进行回收过期记录。</li>
<li>transaction-level事务级别：以事务为粒度回收过期记录。</li>
</ul>
<h3 id="元组级别的回收">元组级别的回收</h3>
<p>两种回收方式</p>
<ul>
<li>后台清理的方式background vacuuming：后台线程定期进行清理</li>
<li>合作式回收cooperative cleaning：工作线程来清理</li>
</ul>
<p><strong>后台清理</strong></p>
<p>Vacuum线程扫描到版本比他TS小的tuple，vacuum的TS应该选择比现在running最小的transactions还小的TS。</p>
<blockquote>
<p>TS为自增版本号，每个事务启动时分配一个此TS作为其可见性判断。</p>
</blockquote>
<p><strong>合作式回收</strong></p>
<p>工作线程执行事务操作时，扫描到过期不可见的版本记录则直接删除，这样就不再需要单独的后台线程来定期清理了，但如果某条记录一直没有被事务扫描到，则永远无法被清理。</p>
<p><strong>混合式</strong><br>
使用合作式回收，然而定期再用后台清理方式，来避免有的数据没有被读取则无法回收的问题。</p>
<h3 id="事务级别的回收">事务级别的回收</h3>
<p>事务维护一个读集合和写集合，分别存储其读到的记录和创建的记录，当事务结束后，再从两个集合中找出对于运行中事务不再可见的记录，将他们删除掉。</p>
<h2 id="索引管理">索引管理</h2>
<p>索引管理是指数据库中的索引，如何指向实际的主表数据？<br>
有两种方式</p>
<ul>
<li>逻辑指针 logical pointer</li>
<li>物理指针 physical pointer</li>
</ul>
<figure>
<img src="https://auto.tancdn.com/v1/images/eyJpZCI6IjRTVExKUUdLSEhRUk1NQ0cyQUtLU0JBQU9MREgyTjEwIiwidyI6OTUwLCJoIjoyODAsImQiOjAsIm10IjoiaW1hZ2UvanBlZyIsImRoIjoxNDc2NDczODY5MDE2MjY0ODA2NH0?format=originalOFGHLERTH" alt="image"><figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="逻辑指针">逻辑指针</h3>
<p>索引指向一个"中间指针"即逻辑指针，这个中间指针再指向主表存储的元组的位置(某个页面的某个位置)，如图所示。</p>
<p>这种方式对于写比较友好，例如，如果更新某条记录，则这条记录相关的所有索引都不需要更新，只需要更新"中间指针"指向新的元组的位置即可。<br>
但是存在读放大问题，所有索引访问数据都需要先访问"中间指针"，再跳转到实际数据存储位置。</p>
<p>MySQL InnoDB就是使用逻辑指针的方式，所有索引都指向主键，通过主键再去访问真实的数据。</p>
<h3 id="物理指针">物理指针</h3>
<p>所有索引都指向主表存储的元组的真实位置。</p>
<p>这种方式和逻辑指针刚好相反，对于读比较友好，索引指向元组的实际位置，直接就可以访问到元组，无需通过中间指针进行跳转。<br>
但不利于写，如果更新了某条记录的位置，则相关的索引都需要更新，造成写放大。</p>
<p>PostgreSQL使用这种方式，所以更新记录时成本较高。</p>
<h2 id="隔离级别-1">隔离级别</h2>
<p>MVCC不是单独可以使用的技术，需要配合其他并发控制技术一起来实现不同的隔离级别，如S2PL。</p>
<p>那我们来看看MVCC+S2PL如何实现不同的隔离级别。</p>
<p><strong>事务号</strong><br>
数据有多个版本由不同的版本号区分，这种版本号就是一个事务号，是一个单调递增的数字。</p>
<p>将事务分成两种类型：只读事务和更新事务。</p>
<ul>
<li>如果是只读事务：则在事务开始时获取一个事务号，读取数据时，就读取比这个事务号小的版本号的数据。这种读取是不用加锁的。</li>
<li>如果是更新事务：
<ul>
<li>读操作：获取共享锁，读取最新版本的值</li>
<li>写操作：获取排它锁，为写的数据创建一个新版本，版本号为无穷大(版本号类型的最大值，当然实际数据库很少这样实现的，考虑到崩溃恢复和持久化，实际数据库实现的版本控制和可见性判断远比这复杂，属于工程上的优化，目的是一样的)，这样其他事务根据其版本号就无法读取到这条记录，提交时，重新获取事务号，将此写入的数据的版本号改为此事务的事务号+1。</li>
</ul></li>
</ul>
<p>所以MVCC天然就不会读取到未提交数据。</p>
<p><strong>读已提交</strong></p>
<p>每次读都重新获取一次快照，读取最新已提交数据。</p>
<p><strong>可重复读</strong></p>
<p>第一次执行读操作时生成快照，后面的读都以此快照进行读取，这样每次读取的版本都是一样的。</p>
<p>如果是<code>SELECT ... FOR UPDATE</code>或DML语句，需要用排它锁锁住需要读写操作的数据直到数据结束。</p>
<p><strong>可串行化</strong></p>
<p>可串行化用SS2PL来实现。</p>
<p>这样，通过MVCC+S2PL实现了数据库的不同隔离级别。</p>
<h1 id="基于可串行化快照隔离的并发控制">基于可串行化快照隔离的并发控制</h1>
<h2 id="快照">快照</h2>
<p>快照snapshot<br>
数据库中数据和状态的某一版本（可以认为只要哪怕有一个数据修改，数据库就会产生一个新版本）。</p>
<h2 id="快照隔离">快照隔离</h2>
<p>快照隔离 snapshot isolation</p>
<blockquote>
<p>snapshot isolation is a guarantee that all reads made in a transaction will see a consistent snapshot of the database (in practice it reads the last committed values that existed at the time it started), and the transaction itself will successfully commit only if no updates it has made conflict with any concurrent updates made since that snapshot.</p>
</blockquote>
<p>事务像是被"隔离"起来了，对同一数据的操作互相不影响；快照隔离只是一种技术，而不是隔离级别，</p>
<p>快照隔离（后面同一写成SI）技术是MVCC技术的一种实现，所以使用SI的读操作，读到的同一份快照的数据一定是一样的。 SI读取的是数据的某一快照，所以不会发生读写冲突或写读冲突。 这样就避免了幻读异常，不可重复读，脏读，但是SI无法阻止写偏序，所以SI并不是可串行化的。</p>
<p>由于SI是MVCC的一种实现，所以避免异常的实现和前面的MVCC的一样，但是没有锁的保护，所以会产生写偏斜异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">database, version 11</span><br><span class="line">x=10, y=0，约束是 x + y &gt; 0</span><br><span class="line">------------------------------------------</span><br><span class="line">T1                          T2</span><br><span class="line">read(x,v11)=10              read(x,v11)=10   </span><br><span class="line">read(y,v11)=0               read(y,v11)=0</span><br><span class="line">if (x+y) &gt; 0,then           if (x+y) &gt; 0,then</span><br><span class="line">    write(x,v12)=0              write(y,v13)=0</span><br></pre></td></tr></table></figure>
<p>对于SI来说，T1和T2读取的都是某一个快照v11的值，所以<code>if (x+y)&gt;0</code>就会成立，T1将x改成0，T2将y改成0，这样就造成x+y=0了，违反了约束。在串行调度下，不管T1先执行还是T2先执行，都不会出现这种结果。这种异常被称为写偏序(write skew)。</p>
<p>为了解决write skew问题，所以就出现了可序列化的快照隔离技术serializable snapshot isolation(SSI)。</p>
<h2 id="可序列化的快照隔离技术">可序列化的快照隔离技术</h2>
<p>serializable snapshot isolation(SSI)</p>
<p>既然write skew是读写冲突的一种类型，那么避免或者检测读写冲突就可以解决write skew问题。</p>
<h3 id="理论基础">理论基础</h3>
<p><strong>三种依赖关系</strong></p>
<p>《Generialized isolation level definitions》定义三种依赖关系</p>
<ul>
<li>写读依赖(write-depends)：T1--wr--&gt;T2，T1写数据项X的一个版本，T2读取这个版本，意味着T1先于T2执行</li>
<li>写写依赖(read-depends)：T1--ww--&gt;T2，T1写X的一个版本，T2再写一个新版本覆盖T1写的版本，意味着T1需要先于T2执行</li>
<li>读写依赖(anti-depends)：rw-dependency或rw-conflicts，Ti先读了X的一个版本Xi，而Tj修改了X值，产生一个新版本Xj，所以是先读后写，属于wr的反向依赖</li>
</ul>
<figure>
<img src="https://auto.tancdn.com/v1/images/eyJpZCI6IklQSUM1WkxMRTRKWTdNQ0JISDVONFRDMkZBTkJHUjExIiwidyI6MTM3NiwiaCI6NDMzLCJkIjowLCJtdCI6ImltYWdlL2pwZWciLCJkaCI6MTQxNTMxMTA0NTQzMjE3MjIzOTN9?format=originalOFGHLERTH" alt="image"><figcaption aria-hidden="true">image</figcaption>
</figure>
<p>检测写偏序的理论基础的两篇论文，说明读写冲突行为之间的逻辑关系</p>
<ul>
<li>《weak consistency: A Generalized Theory and Optimistic Implementations for Distributed Transactions》：定义了读写依赖，通过读写依赖表明不可串行化必须是多版本可串行化图(MVSG multivertion serialization graphc)存在两条读写依赖边形成的环。</li>
<li>《Making snapshot isolation serializable》：定义读写依赖的扩展形式，表明写偏序发生时，两条读写依赖的边是相邻的。</li>
</ul>
<p><strong>DSG direct serialization graph</strong></p>
<p>在并发事务之间，根据事务之间的三种关系，画出一幅有向事务关系图，表明事务操作数据时的前后关系，读写操作对新版本值的依赖关系。</p>
<p>事务T1, T2, T3执行如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">T1          T2          T3</span><br><span class="line">W(z)</span><br><span class="line">W(x)</span><br><span class="line">W(y)</span><br><span class="line">                        W(x)</span><br><span class="line">C</span><br><span class="line">            R(x)</span><br><span class="line">            W(y)</span><br><span class="line">            C</span><br><span class="line">                        R(y)</span><br><span class="line">                        W(z)</span><br><span class="line">                        C</span><br></pre></td></tr></table></figure>
<p>DSG图如下 <img src="https://auto.tancdn.com/v1/images/eyJpZCI6IkVSN1ZFTVI1R1NHN0NJQ0ZRRlM1NkhEVkRCVU9TVDEwIiwidyI6NTc2LCJoIjoyMDcsImQiOjAsIm10IjoiaW1hZ2UvanBlZyIsImRoIjoxMzI4NzE4NjQ3MjE2ODQ5OTIxfQ?format=originalOFGHLERTH" alt="image"></p>
<p>《marking snapshot isolation serializable》中证明了，如果调度不是可序列化的，那么DSG必然存在由两条连续的rw-dependency边形成的环，且这两边边在两个并发事务中。</p>
<blockquote>
<p>Suppose H is a multiversion history produced under Snapshot Isolation that is not serializable. Then there is at least one cycle in the serialization graph DSG(H), and we claim that in every cycle there are three consecutive transactions Ti.1, Ti..2, Ti.3 (where it is possible that Ti.1 and Ti.3 are the same transaction) such that Ti.1 and Ti.2 are concurrent, with an edge Ti.1 --&gt; Ti.2, and Ti.2 and Ti.3 are concurrent with an edge Ti.2 --&gt; Ti.3.</p>
</blockquote>
<blockquote>
<p>any cycle must have two rw-dependency edges that occur consecutively, and further, each of these edges is between two concurrent transactions.</p>
</blockquote>
<p><strong>dangerous structures</strong></p>
<p>然而要找出DSG中是否有环，成本是相当高的，所以论文定义了存在一种危险结构(dangerous structures)，只要在SDG(static dependency graph)图中存在这种危险结构，就会在DSG图中可能存在环，危险结构是出现环的必要非充分条件。同时得出结论，一个SI调度的SDA不存在这种危险结构，这个调度就是可序列化的SI。</p>
<p>《marking snapshot isolation serializable》对dangerous structure的定义如下</p>
<blockquote>
<p>Definition 3.5 (Dangerous Structures). We say that the static dependency graph SDG(A) has a dangerous structure if it contains nodes P, Q and R (some of which may not be distinct) such that: (a) There is a vulnerable anti-dependency edge from R to P (b) There is a vulnerable anti-dependency edge from P to Q (c) Either Q = R or else there is a path in the graph from Q to R; that is, (Q, R) is in the reflexive transitive closure of the edge relationship.</p>
</blockquote>
<p>其使用SDG图的概念，为了更容易理解，我们直接看《serializable isolation for snapshot database》，论文对这种结论进行了补充，且给出了SSI相关算法的实现。</p>
<p>将rw分成两种情况</p>
<ul>
<li>读操作读取的不是最新的值：产生rw依赖。读取的是某快照，所以互相不阻塞。</li>
<li>读操作在写操作之前发生：可能产生rw依赖。读取数据需要加SIREAD锁，写时就会检查是否有SIREAD锁，有则代表有rw依赖。</li>
</ul>
<p>DSG中(MVSG)，存在一个pivot节点（事务），这个节点有两条边（入边，出边），如果存在这个节点，则存在dangerous structure，则可能导致形成环。只要回滚此节点，则会打破环的形成，就可以确保调度是可串行化的。 这样虽然导致了回滚率增加，但是不需要再找出环，只需找出此pivot节点，从而效率大大提高了。</p>
<blockquote>
<p>所以这种危险结构是形成环的必要非充分条件。</p>
</blockquote>
<p>如下图，Tpivot存在入边和出边，所以产生了危险结构，就可能形成环(如果图中点虚线存在)，这个时候，我们只需要回滚Tpivot就破坏了这种结构。</p>
<figure>
<img src="https://auto.tancdn.com/v1/images/eyJpZCI6Ilg2SkZIQ0NCNlNLNFZSSDJMR041RlRQS1BRV0pNNTExIiwidyI6NTc0LCJoIjo0MzgsImQiOjAsIm10IjoiaW1hZ2UvanBlZyIsImRoIjoxMDIzNjAwMzAyNTEzMzU5NzIzMn0?format=originalOFGHLERTH" alt="image"><figcaption aria-hidden="true">image</figcaption>
</figure>
<h3 id="ssi">SSI</h3>
<p>SSI在SI的基础上，增加一些其他判断和操作来实现SSI技术。</p>
<p>数据库需要为每个事务维护两个boolean值，</p>
<ul>
<li>T.inConflict ： 此值指示是否存在rw-dependency从其他事务指向事务T</li>
<li>T.outConflict ： 指示是否存在rw-dependency从事务T指向其他事务</li>
</ul>
<p>如果T.inConflict和T.outConflict都是true，既有入边也有出边，则代表此调度可能是非可串行化的。</p>
<p><strong>Write lock</strong><br>
写锁避免了事务并发执行的写写冲突，遵循SS2PL协议。</p>
<p><strong>SIREAD lock</strong><br>
事务读取了某个版本的数据后，则会在此数据上加上SIREAD锁。 SIREAD锁不阻塞写锁，仅仅是一种标志，代表访问此数据。</p>
<p><strong>事务开始</strong></p>
<p>事务开始时，我们将事务的inConflict和outConflict都设置为false。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">modifified begin(T):</span><br><span class="line">    existing SI code for begin(T)</span><br><span class="line">    set T.inConflict = T.outConflict = false</span><br></pre></td></tr></table></figure>
<p><strong>读操作</strong></p>
<p>T不应该读到（在T开始时还没有完成提交的事务）但在T结束前已经提交的事务才会生成新的T读不到的版本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">modifed read(T, x):</span><br><span class="line">    get lock(key=x, owner=T, mode=SIREAD)   // 设置x的SIREAD</span><br><span class="line">    // x有写锁时，则可能产生rw依赖，如果写事务不提交则不会产生冲突</span><br><span class="line">    if there is a WRITE lock(wl) on x:</span><br><span class="line">        set wl.owner.inConflict=true</span><br><span class="line">        set T.outConflict=true</span><br><span class="line"></span><br><span class="line">    // SSI依旧使用SI算法</span><br><span class="line">    existing SI code for read(T, x) // SI算法实现，读此快照数据</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    // 检查：比当前快照读读到的x值更新的数据版本</span><br><span class="line">    for each version(xNew) of x that is newer than what T read</span><br><span class="line">        // 如果新版本的事务已经提交，则当前事务对其构成rw依赖</span><br><span class="line">        // 如果新版本的事务对其他事务也构成rw依赖，那么就是pivot事务</span><br><span class="line">        if xNew.creator is committed and xNew.creator.outConflict=true:</span><br><span class="line">            abort(T)  // 两个相邻的rw-dep，回滚T</span><br><span class="line">            return UNSAFE_ERROR</span><br><span class="line">        // 否则这是一个rw-dependency关系，此关系是T指向数据x的新版本的创建者事务的</span><br><span class="line">        set xNew.creator.inConflict=true</span><br><span class="line">        set T.outConflict=true</span><br></pre></td></tr></table></figure>
<p><strong>写操作</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">modified write(T,x, xNew):</span><br><span class="line">    get lock(key=x, locker=T, mode=WRITE) // x加WRITE锁</span><br><span class="line">    if there is a SIREAD lock(rl) on x    // 当有SIREAD</span><br><span class="line">      and rl.owner is running             // 且rl.owner(锁持有者)仍然未提交</span><br><span class="line">      or commit(rl.owner) &gt; begin(T)      // 或rl.owner提交晚于T开始时间</span><br><span class="line">        if rl.onwer is committed and rl.owner.inConflict:</span><br><span class="line">            abort(T)</span><br><span class="line">            return UNSAFE_ERROR</span><br><span class="line">        // 否则，这是一个rw-dependency关系，由创建SIREAD锁的事务指向本事务</span><br><span class="line">        set rl.owner.outConflict=true</span><br><span class="line">        set T.inConflict=true</span><br><span class="line">        </span><br><span class="line">    // SI算法实现</span><br><span class="line">    existing SI code for write(T, x, xNew)  </span><br><span class="line">    # do not get WRITE lock again</span><br></pre></td></tr></table></figure>
<p><strong>提交</strong></p>
<p>事务提交后他的SIREAD不释放，是因为提交后事务也会影响其他正在运行的事务。 直到所有这些事务都提交后才可以释放。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">modified commit(T):</span><br><span class="line">    if T.inConflict and T.outConflict</span><br><span class="line">        abort(T)</span><br><span class="line">        return UNSAFE_ERROR</span><br><span class="line">    existing SI code for commit(T)</span><br><span class="line">    release WRITE locks held by T</span><br><span class="line">    do not release SIREAD locks</span><br></pre></td></tr></table></figure>
<blockquote>
<p>所以，可以看出SSI是一种乐观的实现方式，通过事务执行操作时来检测事务之间的依赖关系，如果读写不构成危险结构，则读写可以并发执行，如果构成，则以回滚pivot事务为代价来避免读写冲突。这样就实现了可串行化。</p>
</blockquote>
<h2 id="隔离级别-2">隔离级别</h2>
<p>在RC和RR隔离级别下，SSI和SS2PL+MVCC实现几乎一样。但在可串行化下，SSI本质上是使用MVCC+行级锁+SIREAD来实现可串行化的。</p>
<h1 id="ss2plmvcc-vs-ssi">SS2PL+MVCC vs SSI</h1>
<p>MVCC技术避免了读写冲突，让读读，读写（快照读）可以并发的执行，但仅限制于只读事务与其他事务可以并发；而非快照读写冲突是无法避免的，这个时候就需要S2PL来避免冲突，保证事务的可串行化。</p>
<p>所以很多数据库就是通过这种MVCC+S2PL技术来实现其事务的可串行化。例如MySQL的InnoDB。然而这种方式是悲观的，有的读写冲突是不会造成异常的，有的却会引起写偏斜等异常，S2PL无法进行区分，所以就降低了事务的并发执行。</p>
<p>而PostgreSQL则是通过SSI来实现其事务的可串行化执行，SSI是乐观的实现方式，读写操作时进行检测，如果存在危险结构则可能造成异常，回滚其pivot事务即可，这种方式可以允许一定的读写并发执行，所以相对于MVCC+S2PL的方式性能更为优异。</p>
<p>例如，对于下面的两个事务，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T1         T2</span><br><span class="line"></span><br><span class="line">R(x)</span><br><span class="line">          R(z)</span><br><span class="line">W(y)</span><br><span class="line">          W(x)</span><br></pre></td></tr></table></figure>
<p>T1读取了x，而T2修改了x，所以<code>T1 -- rw --&gt; T2</code>，有读写依赖，<br>
而T2读取了z，如果没有其他并发事务修改z，则T2不会与其他事务产生rw依赖，则T2不会pivot事务，对于这种情况，SSI是运行并发执行的，而S2PL由于读写冲突，是不允许并发执行的。所以，从这点看，SSI的并发度更高。</p>
<p>而论文对SI、SS2PL和SSI的并发度测试结果，也证明了SSI的性能远优异于S2PL。 <img src="https://auto.tancdn.com/v1/images/eyJpZCI6IkRLVVlGWFdUVDdWSFpZQko3NkVaUlNBTUhaUUhLWDEwIiwidyI6NjcyLCJoIjo0NzUsImQiOjAsIm10IjoiaW1hZ2UvanBlZyIsImRoIjoxNTA1MDEzOTkyNjgzMzA2MTU3Mn0?format=originalOFGHLERTH" alt="image"></p>
<h1 id="最后">最后</h1>
<p>并发控制的实现技术非常多，还有基于时间戳的并发控制，基于有效性检查的并发控制等等，但是大多数RDBMS还是基于上面两种技术，也是相对较为主流的实现方案。</p>
<p>本文主要系统性的讲了并发控制相关的理论，然而数据库在工程上的实现是非常复杂的，如PostgreSQL就对锁做了很多优化，还有SSI等等。</p>
<p>我阅读了很多并发控制和事务相关的论文、书籍和资料，不断思考和总结写出本文，希望能给大家带来帮助。如有错误之处，欢迎指正。</p>
<p>主要阅读参考的资料如下：</p>
<ul>
<li>《concurrency control and recovery in database systems》</li>
<li>《generalized isolation level definitions》</li>
<li>《making snapshot isolation serializable》</li>
<li>《serializable Isolation for Snapshot Databases》</li>
<li>《数据库事务处理的艺术》</li>
<li>《postgresql技术内幕：事务处理深度探索》</li>
<li>《database system implementation》</li>
<li>《database system concepts》</li>
</ul>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>Donate comment here</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>Donate</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.png" alt="Ken WeChat Pay">
        <p>WeChat Pay</p>
      </div>
    

    

    

  </div>
</div>

      </div>
    

    
      <div>
        <footer class="post-footer"> 原有内容
<div>    
 
 
<ul class="post-copyright">
  <li class="post-copyright-author">
      <strong>本文作者：</strong>Ken
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="/2022/07/08/database_concurrency_control/" title="数据库并发控制理论">2022/07/08/database_concurrency_control/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权： </strong>
    本站文章均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0 CN</a> 许可协议，请勿用于商业，转载注明出处！
  </li>
</ul>

</div>
      </footer></div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/database/" rel="tag"><i class="fa fa-tag"></i> database</a>
          
            <a href="/tags/PostgreSQL/" rel="tag"><i class="fa fa-tag"></i> PostgreSQL</a>
          
            <a href="/tags/Concurrency-Control/" rel="tag"><i class="fa fa-tag"></i> Concurrency Control</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2022/02/20/database-postgresql-path/" rel="next" title="数据库路径选择理论与postgreSQL实现">
                <i class="fa fa-chevron-left"></i> 数据库路径选择理论与postgreSQL实现
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="Ken">
            
              <p class="site-author-name" itemprop="name">Ken</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/ikenchina" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#概述"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#理论"><span class="nav-number">2.</span> <span class="nav-text">理论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#实现方向"><span class="nav-number">2.1.</span> <span class="nav-text">实现方向</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可串行化"><span class="nav-number">2.2.</span> <span class="nav-text">可串行化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#终态可串行化"><span class="nav-number">2.2.1.</span> <span class="nav-text">终态可串行化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#冲突可串行化"><span class="nav-number">2.2.2.</span> <span class="nav-text">冲突可串行化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#视图可串行化"><span class="nav-number">2.2.3.</span> <span class="nav-text">视图可串行化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可恢复性"><span class="nav-number">2.3.</span> <span class="nav-text">可恢复性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#级联回滚"><span class="nav-number">2.3.1.</span> <span class="nav-text">级联回滚</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#避免级联回滚"><span class="nav-number">2.3.2.</span> <span class="nav-text">避免级联回滚</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#严格性"><span class="nav-number">2.3.3.</span> <span class="nav-text">严格性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#属性关系"><span class="nav-number">2.4.</span> <span class="nav-text">属性关系</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#基于锁的并发控制"><span class="nav-number">3.</span> <span class="nav-text">基于锁的并发控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#pl"><span class="nav-number">3.1.</span> <span class="nav-text">2PL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#s2pl"><span class="nav-number">3.2.</span> <span class="nav-text">S2PL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ss2pl"><span class="nav-number">3.3.</span> <span class="nav-text">SS2PL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#隔离级别"><span class="nav-number">3.4.</span> <span class="nav-text">隔离级别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#多版本并发控制"><span class="nav-number">4.</span> <span class="nav-text">多版本并发控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#版本存储"><span class="nav-number">4.1.</span> <span class="nav-text">版本存储</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#追加方式"><span class="nav-number">4.1.1.</span> <span class="nav-text">追加方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#时间线方式"><span class="nav-number">4.1.2.</span> <span class="nav-text">时间线方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#增量存储方式"><span class="nav-number">4.1.3.</span> <span class="nav-text">增量存储方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#垃圾回收"><span class="nav-number">4.2.</span> <span class="nav-text">垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#元组级别的回收"><span class="nav-number">4.2.1.</span> <span class="nav-text">元组级别的回收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事务级别的回收"><span class="nav-number">4.2.2.</span> <span class="nav-text">事务级别的回收</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#索引管理"><span class="nav-number">4.3.</span> <span class="nav-text">索引管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#逻辑指针"><span class="nav-number">4.3.1.</span> <span class="nav-text">逻辑指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#物理指针"><span class="nav-number">4.3.2.</span> <span class="nav-text">物理指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#隔离级别-1"><span class="nav-number">4.4.</span> <span class="nav-text">隔离级别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#基于可串行化快照隔离的并发控制"><span class="nav-number">5.</span> <span class="nav-text">基于可串行化快照隔离的并发控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#快照"><span class="nav-number">5.1.</span> <span class="nav-text">快照</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#快照隔离"><span class="nav-number">5.2.</span> <span class="nav-text">快照隔离</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可序列化的快照隔离技术"><span class="nav-number">5.3.</span> <span class="nav-text">可序列化的快照隔离技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#理论基础"><span class="nav-number">5.3.1.</span> <span class="nav-text">理论基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ssi"><span class="nav-number">5.3.2.</span> <span class="nav-text">SSI</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#隔离级别-2"><span class="nav-number">5.4.</span> <span class="nav-text">隔离级别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ss2plmvcc-vs-ssi"><span class="nav-number">6.</span> <span class="nav-text">SS2PL+MVCC vs SSI</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#最后"><span class="nav-number">7.</span> <span class="nav-text">最后</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ken</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>








        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>访问
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'p5Hbkh5aS4MFndlbI9msQ0OF-gzGzoHsz',
        appKey: 'gAYKVuvBLmJ2d8V0RrxlrYyF',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  


  

  

</body>
</html>
