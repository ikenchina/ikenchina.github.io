<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="database,PostgreSQL,genetic algorithm,">










<meta name="description" content="对要枚举出查询树上所有路径，从中找出一个代价最小的路径，是个NP问题，计算成本是非常高昂的。而当查询树的关系(表、子查询等)较少时，可以使用动态规划算法枚举出所有的路径找出最优解，但是当关系较多时，枚举的计算成本是我们无法接收的，这时就需要使用一些折中方案，如贪心算法、遗传算法。遗传算法借鉴自然界“优胜劣汰”的法则对路径进化，从而能找出相对较优的查询路径......">
<meta name="keywords" content="database,PostgreSQL,genetic algorithm">
<meta property="og:type" content="article">
<meta property="og:title" content="数据库路径选择理论与postgreSQL实现">
<meta property="og:url" content="http://yoursite.com/2022/02/20/database-postgresql-path/index.html">
<meta property="og:site_name" content="Ken&#39;s blog">
<meta property="og:description" content="对要枚举出查询树上所有路径，从中找出一个代价最小的路径，是个NP问题，计算成本是非常高昂的。而当查询树的关系(表、子查询等)较少时，可以使用动态规划算法枚举出所有的路径找出最优解，但是当关系较多时，枚举的计算成本是我们无法接收的，这时就需要使用一些折中方案，如贪心算法、遗传算法。遗传算法借鉴自然界“优胜劣汰”的法则对路径进化，从而能找出相对较优的查询路径......">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://auto.tancdn.com/v1/images/eyJpZCI6IjZDRTRXNU5FTlVJM1hQWElER1Q0WExLNTNHWE5YWTEwIiwidyI6MTE2OSwiaCI6NDYyLCJkIjowLCJtdCI6ImltYWdlL2pwZWciLCJkaCI6MTQ4ODE4MDkzOTc3MjM5OTExODN9?format=originalOFGHLERTH">
<meta property="og:image" content="https://auto.tancdn.com/v1/images/eyJpZCI6IlRMTFBEUVRCR1BMMldLWTI3MkhUWVlQWDRVMkFDNTEwIiwidyI6MTE4NiwiaCI6NDY2LCJkIjowLCJtdCI6ImltYWdlL2pwZWciLCJkaCI6NzIzNjczMTg2MjA5MzU4MjUyOH0?format=originalOFGHLERTH">
<meta property="og:image" content="https://auto.tancdn.com/v1/images/eyJpZCI6IjVIMk1UVkxGTE5TTUdOQTJHWFBGVkJRT1pYRFZLVjExIiwidyI6MTA2NCwiaCI6MzQyLCJkIjowLCJtdCI6ImltYWdlL2pwZWciLCJkaCI6MTA1NjE2NzUxNjQ4NjI4MjIwNzB9">
<meta property="og:image" content="https://auto.tancdn.com/v1/images/eyJpZCI6IktCWDJGUUhWVlJSTFFXM1pSS1VFQVVSR0RUUkE1NTExIiwidyI6NzE4LCJoIjo2NTYsImQiOjAsIm10IjoiaW1hZ2UvanBlZyIsImRoIjo0Nzc3OTUyNDA0OTYzNTY2NTM4fQ?format=originalOFGHLERTH">
<meta property="og:updated_time" content="2022-02-22T02:45:17.193Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="数据库路径选择理论与postgreSQL实现">
<meta name="twitter:description" content="对要枚举出查询树上所有路径，从中找出一个代价最小的路径，是个NP问题，计算成本是非常高昂的。而当查询树的关系(表、子查询等)较少时，可以使用动态规划算法枚举出所有的路径找出最优解，但是当关系较多时，枚举的计算成本是我们无法接收的，这时就需要使用一些折中方案，如贪心算法、遗传算法。遗传算法借鉴自然界“优胜劣汰”的法则对路径进化，从而能找出相对较优的查询路径......">
<meta name="twitter:image" content="https://auto.tancdn.com/v1/images/eyJpZCI6IjZDRTRXNU5FTlVJM1hQWElER1Q0WExLNTNHWE5YWTEwIiwidyI6MTE2OSwiaCI6NDYyLCJkIjowLCJtdCI6ImltYWdlL2pwZWciLCJkaCI6MTQ4ODE4MDkzOTc3MjM5OTExODN9?format=originalOFGHLERTH">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2022/02/20/database-postgresql-path/">





  <title>数据库路径选择理论与postgreSQL实现 | Ken's blog</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?46ee37f7c4a6bed681519fb13fb55b02";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ken's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description"></h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/02/20/database-postgresql-path/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ken">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ken's blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">数据库路径选择理论与postgreSQL实现</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-02-20T00:00:00+08:00">
                2022-02-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/2022/" itemprop="url" rel="index">
                    <span itemprop="name">2022</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2022/02/20/database-postgresql-path/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2022/02/20/database-postgresql-path/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>浏览
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>次
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>对要枚举出查询树上所有路径，从中找出一个代价最小的路径，是个NP问题，计算成本是非常高昂的。而当查询树的关系(表、子查询等)较少时，可以使用动态规划算法枚举出所有的路径找出最优解，但是当关系较多时，枚举的计算成本是我们无法接收的，这时就需要使用一些折中方案，如贪心算法、遗传算法。遗传算法借鉴自然界“优胜劣汰”的法则对路径进化，从而能找出相对较优的查询路径...... <a id="more"></a></p>
</blockquote>
<h1 id="前言">前言</h1>
<p>数据库将SQL解析成一棵语法树后，就需要将语法树转换成查询树，然而查询树的每一个节点或者节点之间的连接都会有一种或者多种实现算法，而需要从中挑选出最优的节点组合。</p>
<p>路径表示单个表的访问方式(顺序访问、索引访问、点查)、两个表的连接方式(嵌套连接、归并连接、hash连接)以及多个表的连接顺序。 那么优化器需要枚举出所有的路径，从中挑选代价最低的路径来执行。</p>
<p>查询树上有的节点是可以直接进行优化的，如过滤、投影等，在查询树底部先将不需要的数据过滤掉，以减少数据量往查询树上层的传递以及操作的成本，这种优化是显而易见的，是基于经验的，我们称为启发式规则优化。 然而，有的优化是无法直接进行的，例如，<code>A JOIN B</code>，JOIN顺序<code>A JOIN B</code> 或者 <code>B JOIN A</code>都会输出正确的查询树结果，哪种顺序成本最低呢，这就需要基于统计数据来进行估算，找出代价最小的顺序，这种优化我们称之为基于成本的优化。</p>
<h1 id="路径选择理论">路径选择理论</h1>
<p>因为不同的关系访问方式，ORDER、JOIN方式组合和排列非常多，而JOIN的优化是最为复杂的，所以我们就只讨论数据库是如何挑选出最优的JOIN路径的。</p>
<h2 id="join顺序的枚举">JOIN顺序的枚举</h2>
<p>对于OUTER JOIN来说，JOIN顺序是固定的，所以路径数量相对较少(只需要考虑不同JOIN算法组成的路径)；然而对于INNER JOIN来说，表之间的JOIN顺序是可以不同的，这样就可以由不同的JOIN组合、不同的JOIN顺序组成非常多的不同路径。 如<code>A JOIN B JOIN C</code>，路径有：</p>
<ul>
<li>(A⋈B)⋈C ：就有两种排列顺序<code>(A JOIN B) JOIN C</code> 和 <code>C JOIN (A JOIN B)</code></li>
<li><code>(A JOIN C) JOIN B</code></li>
<li><code>A JOIN (C JOIN B)</code></li>
<li>等等</li>
</ul>
<p>我们将所有join顺序组成的树的形态分为</p>
<ul>
<li>左深树left-deep tree：((1⋈2)⋈3)⋈4</li>
<li>右深树right-deep tree：1⋈(2⋈(3⋈4))</li>
<li>紧密树bushy tree: (1⋈2)⋈(3⋈4), ((1⋈2)⋈3)⋈(4⋈5)</li>
</ul>
<figure>
<img src="https://auto.tancdn.com/v1/images/eyJpZCI6IjZDRTRXNU5FTlVJM1hQWElER1Q0WExLNTNHWE5YWTEwIiwidyI6MTE2OSwiaCI6NDYyLCJkIjowLCJtdCI6ImltYWdlL2pwZWciLCJkaCI6MTQ4ODE4MDkzOTc3MjM5OTExODN9?format=originalOFGHLERTH" alt="image"><figcaption aria-hidden="true">image</figcaption>
</figure>
<figure>
<img src="https://auto.tancdn.com/v1/images/eyJpZCI6IlRMTFBEUVRCR1BMMldLWTI3MkhUWVlQWDRVMkFDNTEwIiwidyI6MTE4NiwiaCI6NDY2LCJkIjowLCJtdCI6ImltYWdlL2pwZWciLCJkaCI6NzIzNjczMTg2MjA5MzU4MjUyOH0?format=originalOFGHLERTH" alt="image"><figcaption aria-hidden="true">image</figcaption>
</figure>
<p>JOIN连接的形状 就是一棵full binary tree 的形状，树形态的数量 是一个卡塔兰数(<a href="https://en.wikipedia.org/wiki/Catalan_number" target="_blank" rel="noopener">catalan number</a>)， 所以就有 <span class="math display">\[
C_{n} = \frac{(2(n-1))!}{n!(n-1)!}
\]</span></p>
<p>种形态的树。</p>
<p>而每种形态的树，都会有<code>n!</code>种排列， 所以n种关系(表，子查询等)就会有 <code>(2(n − 1))!∕(n − 1)!</code>种不同的JOIN路径。</p>
<p>例如4个表JOIN，组成的树的形态就有5种，而每种形态 4! 种排列，所以就有5 * 4! =120 种不同的JOIN路径。</p>
<p>如果是7个表连接，就有665280种JOIN路径！那么要将全部的JOIN路径枚举出来，是非常耗时的。</p>
<h2 id="join方式的枚举">JOIN方式的枚举</h2>
<p>JOIN一般有几种实现方式：嵌套连接、归并连接、hash连接等，所以不同的JOIN顺序还有这几种JOIN方式。</p>
<p>如：A⋈B就有两种排列顺序<code>A JOIN B</code> 和 <code>B JOIN A</code></p>
<p>而根据不同的JOIN方式有：</p>
<ul>
<li><code>A nested-loop join B</code></li>
<li><code>A merge join B</code></li>
<li><code>A hash join B</code></li>
</ul>
<p><img src="https://auto.tancdn.com/v1/images/eyJpZCI6IjVIMk1UVkxGTE5TTUdOQTJHWFBGVkJRT1pYRFZLVjExIiwidyI6MTA2NCwiaCI6MzQyLCJkIjowLCJtdCI6ImltYWdlL2pwZWciLCJkaCI6MTA1NjE2NzUxNjQ4NjI4MjIwNzB9"></p>
<h2 id="实现方式">实现方式</h2>
<p>通常数据库使用以下几种方法来从JOIN路径中找出成本最优的路径</p>
<ul>
<li>动态规划：考虑全部子集，从中找出最优子集</li>
<li>贪心算法：考虑部分子集</li>
<li>随机算法：考虑部分子集，常见的有模拟退火算法，随机爬山算法，遗传算法等等</li>
</ul>
<p><strong>动态规划</strong></p>
<p>遍历出所有的路径，记忆路径子集，避免重复计算，通过最优子问题构建出整个问题最优解。<br>
这种方法能够计算出最优路径，但是如果表的个数变多，则“基于代价的动态规划算法”暴露出连接膨胀的问题。依据前面的计算，7个表就有665280种连接顺序，就算有大量子问题能避免重复计算，但整个计算成本还是相当巨大的。</p>
<p>如果表太多，我们就要取舍，追求次最优或者局部最优解(尽量扩大局部性)，如贪心算法、随机算法</p>
<p><strong>贪心算法</strong></p>
<p>贪心算法求解局部最优解，在局部最优解的基础上再去扩大局部最优解，然而这种方法是具有后效性的，得出的结果不一定是最优的。</p>
<p><strong>随机算法</strong></p>
<p>使用贪心算法，前面子问题的解确定下来后，如果子问题的解导致全局的解不是最优，那么就没有修正的余地了。 而随机算法一般是在局部最优解确定下来后，仍然可以以一定概率进行"变化"，以谋求存在一定概率下能打破子问题后效性。</p>
<p>如：遗传算法中，优胜劣汰的规则，会求出局部最优解，但仍然存在一定概率进行"变异"，这样可以存在多个局部解，最优解的被选择概率更高，就确保了在子问题最优而全局不是最优的情况下，仍然有一定概率选择其他子问题解，以谋求得到相对更优的全局解。</p>
<p>不同的数据库选用的算法不一样，有的选用贪心，或者动态规划，或者随机退火等等，而postgreSQL的实现较为灵活，当表较少时，选择动态规划，否则选择遗传算法，还可以允许用户自己定义路径算法。</p>
<hr>
<h1 id="postgresql实现">postgreSQL实现</h1>
<p>postgreSQL的路径生成算法有三种：</p>
<ul>
<li>动态规划</li>
<li>遗传算法</li>
<li>用户自定义</li>
</ul>
<p>路径生成由<code>make_one_rel</code>函数完成，首先为每个基本关系生成不同的访问路径， 再将这些关系作为叶子节点生成JOIN路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RelOptInfo *make_one_rel(PlannerInfo *root, List *joinlist)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    // 为每个关系生成不同的访问路径</span><br><span class="line">    set_base_rel_pathlists(root);</span><br><span class="line"></span><br><span class="line">    // 生成JOIN路径</span><br><span class="line">    rel = make_rel_from_joinlist(root, joinlist);</span><br><span class="line"></span><br><span class="line">    return rel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>生成不同访问路径</strong></p>
<p>遍历所有的关系，为关系生成不同访问路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">static void set_base_rel_pathlists(PlannerInfo *root)</span><br><span class="line">&#123;</span><br><span class="line">	for (rti = 1; rti &lt; root-&gt;simple_rel_array_size; rti++)</span><br><span class="line">	&#123;</span><br><span class="line">		......</span><br><span class="line">		set_rel_pathlist(root, rel, rti, root-&gt;simple_rte_array[rti]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void set_rel_pathlist(PlannerInfo *root, RelOptInfo *rel, Index rti, RangeTblEntry *rte)</span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line">	</span><br><span class="line">		switch (rel-&gt;rtekind)</span><br><span class="line">		&#123;</span><br><span class="line">		    // 关系</span><br><span class="line">			case RTE_RELATION:</span><br><span class="line">			    ......</span><br><span class="line">				else  // 普通关系</span><br><span class="line">				&#123;</span><br><span class="line">					set_plain_rel_pathlist(root, rel, rte);</span><br><span class="line">				&#125;</span><br><span class="line">			......</span><br><span class="line">		&#125;</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">	set_cheapest(rel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看看普通关系如何生成路径的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static void set_plain_rel_pathlist(PlannerInfo *root, RelOptInfo *rel, RangeTblEntry *rte)</span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line">	</span><br><span class="line">	// 顺序扫描路径</span><br><span class="line">	add_path(rel, create_seqscan_path(root, rel, required_outer, 0));</span><br><span class="line"></span><br><span class="line">	// 是否支持索引扫描，支持则添加到路径中</span><br><span class="line">	create_index_paths(root, rel);</span><br><span class="line"></span><br><span class="line">	// 表达式是否可以转成TID扫描，</span><br><span class="line">	create_tidscan_paths(root, rel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成基本访问路径后，就开始进行JOIN路径计算了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static RelOptInfo *make_rel_from_joinlist(PlannerInfo *root, List *joinlist)</span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">	if (levels_needed == 1)</span><br><span class="line">	&#123;   // 只有一个join关系，则直接返回</span><br><span class="line">		return (RelOptInfo *) linitial(initial_rels);</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		......</span><br><span class="line">        // 如果有自定义join生成算法则使用</span><br><span class="line">		if (join_search_hook)</span><br><span class="line">			return (*join_search_hook) (root, levels_needed, initial_rels);</span><br><span class="line">		// 如果开启了遗传算法且join关系大于阈值(默认12)则使用遗传算法</span><br><span class="line">		else if (enable_geqo &amp;&amp; levels_needed &gt;= geqo_threshold)</span><br><span class="line">			return geqo(root, levels_needed, initial_rels);</span><br><span class="line">		else  // 否则，使用动态规划算法</span><br><span class="line">			return standard_join_search(root, levels_needed, initial_rels);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="遗传算法">遗传算法</h2>
<h3 id="算法">算法</h3>
<p>遗传算法：</p>
<ul>
<li>对问题进行编码，确定搜索空间的大小</li>
<li>随机初始化群体（主要是给染色体赋初始值，计算每个染色体的适应度的值，并对各个染色体的适应度排序），以及计算好进化次数</li>
<li>循环：进行N次进化
<ul>
<li>“随机”选出两个染色体，分别是momma和daddy</li>
<li>对于momma和daddy使用“杂交”方式，求出其孩子</li>
<li>求杂交得到的kid的适应度的值</li>
<li>把kid插入群体中（如果kid的适应度比群体中最差的适应度还差，则不插入，否则，替换掉最差的那个且排好序）</li>
</ul></li>
<li>生成了最优路径</li>
<li>根据最优的连接路径生成查询执行计划和花费估算</li>
</ul>
<h3 id="实现">实现</h3>
<p><strong>种群Pool</strong></p>
<p>用来存储染色体，所有染色体在种群中进化出最终的较优染色体。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct Pool</span><br><span class="line">&#123;</span><br><span class="line">   Chromosome *data;      // 染色体数据</span><br><span class="line">   int         size;      // 染色体数量</span><br><span class="line">   int         string_length;  // 染色体大小，用以连接的表的数目</span><br><span class="line">&#125; Pool;</span><br></pre></td></tr></table></figure>
<p><strong>基因Gene</strong></p>
<p>最小进化单位，在这里定义成基本关系，<code>Relid</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef int Gene;</span><br></pre></td></tr></table></figure>
<p><strong>染色体Chromosome</strong></p>
<p>由基因组成，且由<code>worth</code>来表示此染色体的适应度，适应度差的更高的概率会被淘汰掉。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct Chromosome</span><br><span class="line">&#123;</span><br><span class="line">   Gene     *string;  // 基因，是连接表构成的序列即一连串不重复的整数形式的字符串</span><br><span class="line">   Cost     worth;    // 适应度，也就是路径代价</span><br><span class="line">&#125; Chromosome;</span><br></pre></td></tr></table></figure>
<p>postgreSQL实现了几种杂交算法</p>
<ul>
<li>基于边重组杂交 (edge recombination crossover)</li>
<li>部分匹配杂交 (partially matched crossover)</li>
<li>循环杂交 (cycle crossover)</li>
<li>位置杂交 (position crossover)</li>
<li>顺序杂交 (order crossover)</li>
</ul>
<p>由于基于边重组杂交是默认的算法，所以我们这里只讨论此算法。</p>
<h4 id="主流程">主流程</h4>
<p>代码中只保留了基于边重组的杂交算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">RelOptInfo *geqo(PlannerInfo *root, int number_of_rels, List *initial_rels)</span><br><span class="line">&#123;</span><br><span class="line">    int         generation;</span><br><span class="line">    Chromosome *momma;</span><br><span class="line">    Chromosome *daddy;</span><br><span class="line">    Chromosome *kid;</span><br><span class="line">    Pool       *pool;</span><br><span class="line">    int         pool_size,</span><br><span class="line">                number_generations;</span><br><span class="line">    Gene       *best_tour;</span><br><span class="line">    Edge       *edge_table;     /* list of edges */</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    // 计算种群大小</span><br><span class="line">    pool_size = gimme_pool_size(number_of_rels);</span><br><span class="line">    // 计算杂交次数（进化次数）</span><br><span class="line">    number_generations = gimme_number_generations(pool_size);</span><br><span class="line"></span><br><span class="line">    // 分配种群</span><br><span class="line">    pool = alloc_pool(root, pool_size, number_of_rels);</span><br><span class="line"></span><br><span class="line">    // 随机初始化群体（主要是给染色体赋初始值，并调用geqo_eval函数为每个染色体求适应度的值，</span><br><span class="line">    // 调用sort_pool函数对各个染色体的适应度排序）。</span><br><span class="line">    random_init_pool(root, pool);</span><br><span class="line"></span><br><span class="line">    // 按照适应度值（cheapestpath）排序群体中的染色体,</span><br><span class="line">    // 适应度值小表示此路径花费小,应该优先选择</span><br><span class="line">    sort_pool(root, pool);    </span><br><span class="line"></span><br><span class="line">    // 分配父母染色体</span><br><span class="line">    momma = alloc_chromo(root, pool-&gt;string_length);</span><br><span class="line">    daddy = alloc_chromo(root, pool-&gt;string_length);</span><br><span class="line"></span><br><span class="line">    // 创建边表（边重组）</span><br><span class="line">    edge_table = alloc_edge_table(root, pool-&gt;string_length);</span><br><span class="line"></span><br><span class="line">    // 开始进化</span><br><span class="line">    for (generation = 0; generation &lt; number_generations; generation++)</span><br><span class="line">    &#123;</span><br><span class="line">        // 选择:利用线性偏差函数,从中选出父母</span><br><span class="line">        geqo_selection(root, momma, daddy, pool, Geqo_selection_bias);</span><br><span class="line"></span><br><span class="line">        // **基于边重组杂交**</span><br><span class="line">        </span><br><span class="line">        // 通过父母染色体来初始化边表</span><br><span class="line">        gimme_edge_table(root, momma-&gt;string, daddy-&gt;string, pool-&gt;string_length, edge_table);</span><br><span class="line"></span><br><span class="line">        // 分配kid染色体</span><br><span class="line">        kid = momma;</span><br><span class="line"></span><br><span class="line">        // 杂交 ：从边表中选择合适的基因组成新的染色体</span><br><span class="line">        edge_failures += gimme_tour(root, edge_table, kid-&gt;string, pool-&gt;string_length);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        // 计算kid的适应度，通过gimme_tree构造最优路径</span><br><span class="line">        kid-&gt;worth = geqo_eval(root, kid-&gt;string, pool-&gt;string_length);</span><br><span class="line"></span><br><span class="line">        // 进化：</span><br><span class="line">        // 将kid插入种群中，如果kid比种群中最差的个体适应度差，则不插入</span><br><span class="line">        // 否则使用二分查找到合适位置替换掉适应度比kid差的个体</span><br><span class="line">        spread_chromo(root, kid, pool);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 把最优路径传递给gimme_tree</span><br><span class="line">    best_tour = (Gene *) pool-&gt;data[0].string;</span><br><span class="line">    best_rel = gimme_tree(root, best_tour, pool-&gt;string_length);</span><br><span class="line">    ......</span><br><span class="line">    return best_rel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="确定种群大小">确定种群大小</h4>
<p>种群越大，理论上就越能找出最优解，但就会导致计算成本的增加，所以要对种群大小进行取舍。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static int gimme_pool_size(int nr_rel)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    // 如果指定了群体的大小，指定值大于等于2，则采用指定值为群体大小</span><br><span class="line">    if (Geqo_pool_size &gt;= 2)</span><br><span class="line">        return Geqo_pool_size;</span><br><span class="line"></span><br><span class="line">    // size = 2^(nr_rel + 1)</span><br><span class="line">    size = pow(2.0, nr_rel + 1.0);</span><br><span class="line"></span><br><span class="line">    // 约束</span><br><span class="line">    maxsize = 50 * Geqo_effort; /* 50 to 500 individuals */</span><br><span class="line">    if (size &gt; maxsize)</span><br><span class="line">        return maxsize;</span><br><span class="line"></span><br><span class="line">    minsize = 10 * Geqo_effort; /* 10 to 100 individuals */</span><br><span class="line">    if (size &lt; minsize)</span><br><span class="line">        return minsize;</span><br><span class="line"></span><br><span class="line">    return (int) ceil(size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="初始化种群">初始化种群</h4>
<p>随机初始化种群</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void random_init_pool(PlannerInfo *root, Pool *pool)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    while (i &lt; pool-&gt;size)</span><br><span class="line">    &#123;</span><br><span class="line">        init_tour(root, chromo[i].string, pool-&gt;string_length);</span><br><span class="line">        pool-&gt;data[i].worth = geqo_eval(root, chromo[i].string, pool-&gt;string_length);</span><br><span class="line">        if (pool-&gt;data[i].worth &lt; DBL_MAX)</span><br><span class="line">            i++;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            bad++;</span><br><span class="line">            if (i == 0 &amp;&amp; bad &gt;= 10000)</span><br><span class="line">                elog(ERROR, &quot;geqo failed to make a valid plan&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>生成染色体</strong></p>
<p>改进的Fisher-Yates洗牌算法， 利用了编码有序的特点，将初始化染色体和随机交换结合起来一起进行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 随机生成连接顺序</span><br><span class="line">void init_tour(PlannerInfo *root, Gene *tour, int num_gene)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    if (num_gene &gt; 0)</span><br><span class="line">        tour[0] = (Gene) 1;</span><br><span class="line"></span><br><span class="line">    for (i = 1; i &lt; num_gene; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        j = geqo_randint(root, i, 0);</span><br><span class="line">        // 交换i和j的值（i并没有初始化）</span><br><span class="line">        /* i != j check avoids fetching uninitialized array element */</span><br><span class="line">        if (i != j)</span><br><span class="line">            tour[i] = tour[j];     //将tour[j]的值赋值给tour[i]</span><br><span class="line">        tour[j] = (Gene) (i + 1);  // tour[i]之前的值(初始化)赋值给tour[j]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="适应度">适应度</h4>
<p><code>geqo_eval</code>函数的主要只有两步</p>
<ul>
<li>通过<code>gimme_tree</code>函数进行多表连接</li>
<li>计算连接结果的适应度值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Cost geqo_eval(PlannerInfo *root, Gene *tour, int num_gene)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    // 进行多表连接</span><br><span class="line">    joinrel = gimme_tree(root, tour, num_gene);</span><br><span class="line"></span><br><span class="line">    if (joinrel)</span><br><span class="line">    &#123;   // 计算连接结果的适应度</span><br><span class="line">        Path       *best_path = joinrel-&gt;cheapest_total_path;</span><br><span class="line"></span><br><span class="line">        fitness = best_path-&gt;total_cost;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">        fitness = DBL_MAX;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    return fitness;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="选择染色体">选择染色体</h4>
<p>由于种群中的染色体已经按照适应度排好序了，对我们来说适应度越低（代价越低）的染色体越好，因此选择操作基于概率分布的随机。 这样在选择父亲染色体和母亲染色体的时候更倾向于选择适应度低的染色体，同时也有机会选择非局部最优染色体，以达到能够一定随机性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void geqo_selection(PlannerInfo *root, Chromosome *momma, Chromosome *daddy, Pool *pool, double bias)</span><br><span class="line">&#123;</span><br><span class="line">    int         first,</span><br><span class="line">                second;</span><br><span class="line">    </span><br><span class="line">    // 选择两个随机数(基于概率分布的)</span><br><span class="line">    first = linear_rand(root, pool-&gt;size, bias);</span><br><span class="line">    second = linear_rand(root, pool-&gt;size, bias);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    // 在种群中基于随机数选择父母染色体</span><br><span class="line">    geqo_copy(root, momma, &amp;pool-&gt;data[first], pool-&gt;string_length);</span><br><span class="line">    geqo_copy(root, daddy, &amp;pool-&gt;data[second], pool-&gt;string_length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>线性随机</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static int linear_rand(PlannerInfo *root, int pool_size, double bias)</span><br><span class="line">&#123;</span><br><span class="line">	double		index;			/* index between 0 and pool_size */</span><br><span class="line">	double		max = (double) pool_size;</span><br><span class="line"></span><br><span class="line">	do</span><br><span class="line">	&#123;</span><br><span class="line">		double		sqrtval;</span><br><span class="line"></span><br><span class="line">		sqrtval = (bias * bias) - 4.0 * (bias - 1.0) * geqo_rand(root);</span><br><span class="line">		if (sqrtval &gt; 0.0)</span><br><span class="line">			sqrtval = sqrt(sqrtval);</span><br><span class="line">		index = max * (bias - sqrtval) / 2.0 / (bias - 1.0);</span><br><span class="line">	&#125; while (index &lt; 0.0 || index &gt;= max);</span><br><span class="line"></span><br><span class="line">	return (int) index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先生成一个基于[0, 1]之间的随机值，然后根据概率分布函数求出符合概率密度的随机值。</p>
<p>生成基于某种概率分布的随机数，要先计算其概率密度函数，postgreSQL的概率密度函数为</p>
<p><span class="math display">\[
f(x) = bias - 2(bias -1)x, (0&lt;x&lt;1)
\]</span></p>
<p>bias默认是2，所以 概率密度函数 <code>f(x) = 2-2x</code>，代表概率的变化率。</p>
<p>通过概率密度函数获得概率分布函数</p>
<p><span class="math display">\[
F(x) = \int f(x)dx = bias \times x - (bias - 1) \times x^2, (0&lt;x&lt;1)
\]</span></p>
<p>通过概率分布函数的逆函数法可以获得符合概率分布的随机数</p>
<p><span class="math display">\[
F^{-1}(x) =  \frac{bias - \sqrt{bias^2 - 4(bias - 1)y}}{2(bias - 1)}
\]</span></p>
<p>求得概率分布函数如图中红色曲线， 概率分布函数逆函数如图中蓝线，</p>
<figure>
<img src="https://auto.tancdn.com/v1/images/eyJpZCI6IktCWDJGUUhWVlJSTFFXM1pSS1VFQVVSR0RUUkE1NTExIiwidyI6NzE4LCJoIjo2NTYsImQiOjAsIm10IjoiaW1hZ2UvanBlZyIsImRoIjo0Nzc3OTUyNDA0OTYzNTY2NTM4fQ?format=originalOFGHLERTH" alt="image"><figcaption aria-hidden="true">image</figcaption>
</figure>
<p>从图中红色曲线可以看出，在X轴上递增，则概率越低（连续型随机变量）。<br>
如：F(x)d(0 ~ 0.2)的概率就比F(x)d(0.4 ~ 0.6)高。</p>
<p>而蓝色曲线是概率分布函数的逆函数，值域(Y轴)为随机变量，在X轴上选定任意的p(0&lt;=p&lt;=1)时，通过逆函数得到的是随机变量的值，也就是获得概率和为p的随机变量的上限。<br>
所以通过逆函数，可以将<code>rand(0, 1)</code> “转换成” 符合概率密度分布的随机值。</p>
<p>测试：将linear_rand代码提取出来，进化10000次，种群选择10，那么10条染色体被选中的概率分别为18.8%，16.9%，15.5%，12.9%，11.3%，9.3%，6.3%，5.1%，2.8%，1.1%，可以看出概率变化是符合概率密度函数 <code>f(x) = 2-2x</code>的。</p>
<p><strong>bias的选择</strong><br>
密度函数中bias越大，则适应度低的染色体被选择概率更高，随着进化次数越多，产生"近亲繁殖"的概率就越高，也就越容易造成贪心算法类似的问题；<br>
bias越小，则"优胜劣汰"的速度越慢，需要的进化次数越多，但是，最终找出最优解的可能性也越高。</p>
<h4 id="杂交算法">杂交算法</h4>
<p>默认的杂交算法是：<a href="https://en.wikipedia.org/wiki/Edge_recombination_operator" target="_blank" rel="noopener">基于边重组的杂交</a>。</p>
<p><strong>算法</strong></p>
<p>如2条染色体</p>
<ul>
<li>染色体1：(A, D, C, B)</li>
<li>染色体2：(C, B, D, A)</li>
</ul>
<p>边关系</p>
<ul>
<li>视染色体为循环队列：染色体1中A与B是有边关系的</li>
<li>边关系是双向的：如染色体1中，基因A和D的边关系为(A, D)和(D, A)</li>
</ul>
<p>我们使用一个边表来存储染色体的基因之间的边关系</p>
<ul>
<li>A -&gt; (-D, B, C) ： 表示基因A和(D, B, C)有边关系，而(-D)表示有2条这样的边关系，称为共享边</li>
<li>B -&gt; (A, -C, D)</li>
<li>C -&gt; (D, -B, A)</li>
<li>D -&gt; (-A, C, B)</li>
</ul>
<p>在交叉过程中，会尽量选择共享边，这样可以达到选择较优基因的目的。</p>
<p><strong>边表</strong></p>
<p>边表用来存储染色体中基因的边关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct Edge</span><br><span class="line">&#123;</span><br><span class="line">	Gene		edge_list[4];	// 每个基因有4条边(2条染色体，前后左右各2条)</span><br><span class="line">	int			total_edges;   // 总的数量</span><br><span class="line">	int			unused_edges;  // 没有选择的边数量</span><br><span class="line">&#125; Edge;</span><br></pre></td></tr></table></figure>
<p><code>alloc_edge_table</code>分配表边，为<code>总数=基因+1</code>的边。</p>
<p><strong>根据染色体来填充边表</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">// tour1和tour2为2条染色体</span><br><span class="line">float gimme_edge_table(PlannerInfo *root, Gene *tour1, Gene *tour2, int num_gene, Edge *edge_table)</span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">    // index1和index2为2个基因的索引</span><br><span class="line">	for (index1 = 0; index1 &lt; num_gene; index1++)</span><br><span class="line">	&#123;</span><br><span class="line">		// </span><br><span class="line">		index2 = (index1 + 1) % num_gene;</span><br><span class="line">    </span><br><span class="line">        // 边是双向的，填充1-&gt;2，也填充2-&gt;1</span><br><span class="line">        // 填充tour1染色体的边关系</span><br><span class="line">		edge_total += gimme_edge(root, tour1[index1], tour1[index2], edge_table);</span><br><span class="line">		gimme_edge(root, tour1[index2], tour1[index1], edge_table);</span><br><span class="line">        </span><br><span class="line">        // 填充tour2染色体的边关系</span><br><span class="line">		edge_total += gimme_edge(root, tour2[index1], tour2[index2], edge_table);</span><br><span class="line">		gimme_edge(root, tour2[index2], tour2[index1], edge_table);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return ((float) (edge_total * 2) / (float) num_gene);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int gimme_edge(PlannerInfo *root, Gene gene1, Gene gene2, Edge *edge_table)</span><br><span class="line">&#123;</span><br><span class="line">    int         i;</span><br><span class="line">    int         edges;</span><br><span class="line">    int         city1 = (int) gene1;</span><br><span class="line">    int         city2 = (int) gene2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // edge_list： city1指向的基因的边，如基因A-&gt;B，A-&gt;C, A-&gt;M，edges存储[B,C,M]</span><br><span class="line">    // 边数量</span><br><span class="line">    edges = edge_table[city1].total_edges;</span><br><span class="line">    </span><br><span class="line">    // 如果基因city1-&gt;city2已经存在，说明其他染色体也有此边关系</span><br><span class="line">    // 则在city1的edge_list中city2改写成 -city2，</span><br><span class="line">    // 即[-B, C, M]，表示这是共享边</span><br><span class="line">    for (i = 0; i &lt; edges; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if ((Gene) Abs(edge_table[city1].edge_list[i]) == city2)</span><br><span class="line">        &#123;</span><br><span class="line">            edge_table[city1].edge_list[i] = 0 - city2;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 添加city1-&gt;city2边关系</span><br><span class="line">    edge_table[city1].edge_list[edges] = city2;</span><br><span class="line"></span><br><span class="line">    edge_table[city1].total_edges++;</span><br><span class="line">    edge_table[city1].unused_edges++;</span><br><span class="line"></span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>通过边表，生成新的染色体</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int gimme_tour(PlannerInfo *root, Edge *edge_table, Gene *new_gene, int num_gene)</span><br><span class="line">&#123;</span><br><span class="line">    int         i;</span><br><span class="line">    int         edge_failures = 0;</span><br><span class="line"></span><br><span class="line">    // 随机选择一个基因</span><br><span class="line">    new_gene[0] = (Gene) geqo_randint(root, num_gene, 1);</span><br><span class="line"></span><br><span class="line">    for (i = 1; i &lt; num_gene; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        // 将边表中，指向new_gene[i-1]的边删除掉</span><br><span class="line">        remove_gene(root, new_gene[i - 1], edge_table[(int) new_gene[i - 1]], edge_table);</span><br><span class="line"></span><br><span class="line">        // 如果new_gene[i-1]的edge_list中还有边关系，则从中找一个比较&quot;合适&quot;的边关系</span><br><span class="line">        if (edge_table[new_gene[i - 1]].unused_edges &gt; 0)</span><br><span class="line">            new_gene[i] = gimme_gene(root, edge_table[(int) new_gene[i - 1]], edge_table);</span><br><span class="line">        else</span><br><span class="line">        &#123;  // 如果new_gene[i-1]的edge_list中国没有边关系，则随机找一个new_gene中没有的基因</span><br><span class="line">            edge_failures++;</span><br><span class="line">            new_gene[i] = edge_failure(root, new_gene, i - 1, edge_table, num_gene);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        edge_table[(int) new_gene[i - 1]].unused_edges = -1;</span><br><span class="line">    &#125;                           /* for (i=1; i&lt;num_gene; i++) */</span><br><span class="line"></span><br><span class="line">    return edge_failures;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从基因的边关系中找出一条“合适的”边关系</p>
<ul>
<li>优先选择共享边关系：共享边是指某条边在父母中都存在，也说明2个基因组成的这条边是较优的，所以要尽量继承下去。</li>
<li>从邻居基因的边关系中，找出其边关系最少的邻居</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">static Gene gimme_gene(PlannerInfo *root, Edge edge, Edge *edge_table)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    minimum_edges = 5;</span><br><span class="line"></span><br><span class="line">    // 遍历边关系</span><br><span class="line">    for (i = 0; i &lt; edge.unused_edges; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        friend = (Gene) edge.edge_list[i];</span><br><span class="line"></span><br><span class="line">        // 优先选择共享边</span><br><span class="line">        if (friend &lt; 0)</span><br><span class="line">            return (Gene) Abs(friend);</span><br><span class="line"></span><br><span class="line">        // 在所有邻居基因中，找出边关系最少的</span><br><span class="line">        if (edge_table[(int) friend].unused_edges &lt; minimum_edges)</span><br><span class="line">        &#123;</span><br><span class="line">            minimum_edges = edge_table[(int) friend].unused_edges;</span><br><span class="line">            minimum_count = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (minimum_count == -1)</span><br><span class="line">            elog(ERROR, &quot;minimum_count not set&quot;);</span><br><span class="line">        else if (edge_table[(int) friend].unused_edges == minimum_edges)</span><br><span class="line">            minimum_count++;</span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    rand_decision = geqo_randint(root, minimum_count - 1, 0);</span><br><span class="line"></span><br><span class="line">    // 在&quot;边关系最少的&quot;邻居基因中随机选择一个</span><br><span class="line">    for (i = 0; i &lt; edge.unused_edges; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        friend = (Gene) edge.edge_list[i];</span><br><span class="line"></span><br><span class="line">        /* return the chosen candidate point */</span><br><span class="line">        if (edge_table[(int) friend].unused_edges == minimum_edges)</span><br><span class="line">        &#123;</span><br><span class="line">            minimum_count--;</span><br><span class="line"></span><br><span class="line">            if (minimum_count == rand_decision)</span><br><span class="line">                return friend;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    elog(ERROR, &quot;neither shared nor minimum number nor random edge found&quot;);</span><br><span class="line">    return 0;                   /* to keep the compiler quiet */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，我们就通过边重组的方式，产生出较优的染色体。</p>
<h4 id="生成连接路径">生成连接路径</h4>
<p>根据指定的染色体，生成最佳路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">RelOptInfo *gimme_tree(PlannerInfo *root, Gene *tour, int num_gene)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    clumps = NIL;</span><br><span class="line">    // 遍历所有基因</span><br><span class="line">    for (rel_count = 0; rel_count &lt; num_gene; rel_count++)</span><br><span class="line">    &#123;</span><br><span class="line">    	......</span><br><span class="line">    	</span><br><span class="line">        // 提取关系， Get the next input relation </span><br><span class="line">        cur_rel_index = (int) tour[rel_count];</span><br><span class="line">        cur_rel = (RelOptInfo *) list_nth(private-&gt;initial_rels, cur_rel_index - 1);</span><br><span class="line"></span><br><span class="line">        /* Make it into a single-rel clump */</span><br><span class="line">        cur_clump = (Clump *) palloc(sizeof(Clump));</span><br><span class="line">        cur_clump-&gt;joinrel = cur_rel;</span><br><span class="line">        cur_clump-&gt;size = 1;</span><br><span class="line"></span><br><span class="line">        // clumps初始是NIL，不断增加可做连接的连接后的关系。</span><br><span class="line">        // merge_clump函数的作用就是把cur_clump和clumps中的每个可连接的关系进行连接，</span><br><span class="line">        // 连接的结果放于clumps中</span><br><span class="line">        /* Merge it into the clumps list, using only desirable joins */</span><br><span class="line">        clumps = merge_clump(root, clumps, cur_clump, num_gene, false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (list_length(clumps) &gt; 1)</span><br><span class="line">    &#123;</span><br><span class="line">        /* Force-join the remaining clumps in some legal order */</span><br><span class="line">        List       *fclumps;</span><br><span class="line">        ListCell   *lc;</span><br><span class="line">        fclumps = NIL;</span><br><span class="line">        </span><br><span class="line">        foreach(lc, clumps)</span><br><span class="line">        &#123;</span><br><span class="line">            Clump      *clump = (Clump *) lfirst(lc);</span><br><span class="line">            fclumps = merge_clump(root, fclumps, clump, num_gene, true);</span><br><span class="line">        &#125;</span><br><span class="line">        clumps = fclumps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* Did we succeed in forming a single join relation? */</span><br><span class="line">    if (list_length(clumps) != 1)</span><br><span class="line">        return NULL;</span><br><span class="line"></span><br><span class="line">    return ((Clump *) linitial(clumps))-&gt;joinrel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>new_clump与clumps中每项进行连接，如果可以连接（且连接顺序符合染色体）， 则连接并加入到clumps中，如果不可以，则将new_clump加入到clumps中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">static List *merge_clump(PlannerInfo *root, List *clumps, Clump *new_clump, int num_gene, bool force)</span><br><span class="line">&#123;</span><br><span class="line">    ListCell   *lc;</span><br><span class="line">    int         pos;</span><br><span class="line"></span><br><span class="line">    foreach(lc, clumps)</span><br><span class="line">    &#123;</span><br><span class="line">        Clump      *old_clump = (Clump *) lfirst(lc);</span><br><span class="line">        if (force || desirable_join(root, old_clump-&gt;joinrel, new_clump-&gt;joinrel))</span><br><span class="line">        &#123;</span><br><span class="line">            RelOptInfo *joinrel;</span><br><span class="line">            // 完成关系连接处理</span><br><span class="line">            joinrel = make_join_rel(root, old_clump-&gt;joinrel, new_clump-&gt;joinrel);</span><br><span class="line">            if (joinrel)</span><br><span class="line">            &#123;</span><br><span class="line">                generate_partitionwise_join_paths(root, joinrel);</span><br><span class="line"></span><br><span class="line">                if (old_clump-&gt;size + new_clump-&gt;size &lt; num_gene)</span><br><span class="line">                    generate_useful_gather_paths(root, joinrel, false);</span><br><span class="line"></span><br><span class="line">                // 找关系上的最优路径</span><br><span class="line">                /* Find and save the cheapest paths for this joinrel */</span><br><span class="line">                set_cheapest(joinrel);</span><br><span class="line"></span><br><span class="line">                old_clump-&gt;joinrel = joinrel;</span><br><span class="line">                old_clump-&gt;size += new_clump-&gt;size;</span><br><span class="line">                pfree(new_clump);</span><br><span class="line"></span><br><span class="line">                /* Remove old_clump from list */</span><br><span class="line">                // 去掉old_clump,保证下步递归调用merge_clump函数时不和自身连接</span><br><span class="line">                clumps = foreach_delete_current(clumps, lc);</span><br><span class="line"></span><br><span class="line">                return merge_clump(root, clumps, old_clump, num_gene, force);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (clumps == NIL || new_clump-&gt;size == 1)</span><br><span class="line">        return lappend(clumps, new_clump);</span><br><span class="line"></span><br><span class="line">    for (pos = 0; pos &lt; list_length(clumps); pos++)</span><br><span class="line">    &#123;</span><br><span class="line">        Clump      *old_clump = (Clump *) list_nth(clumps, pos);</span><br><span class="line">        if (new_clump-&gt;size &gt; old_clump-&gt;size)</span><br><span class="line">            break;            </span><br><span class="line">    &#125;</span><br><span class="line">    clumps = list_insert_nth(clumps, pos, new_clump);</span><br><span class="line"></span><br><span class="line">    return clumps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态规划">动态规划</h2>
<h3 id="算法-1">算法</h3>
<p><strong>过程</strong></p>
<ul>
<li>第一步 ： 初始化第1层关系，为基本关系节点，包含基本关系的数据访问路径</li>
<li>第二步 ：生成第2层到第n层关系：
<ul>
<li>左右深树连接方式：将第2层到第n-1层的每个关系，与第1层中的每个关系连接，生成新的关系，每一个新关系，均求出最优路径</li>
<li>紧密树连接方式：将第k层(2&lt;=k&lt;=n-k)的每个关系，与第other_level层(n-k)中的每个关系连接，生成新的关系放于第n层，且每一个新关系，均求解其最优路径</li>
</ul></li>
</ul>
<h3 id="实现-1">实现</h3>
<h4 id="主流程-1">主流程</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">RelOptInfo *standard_join_search(PlannerInfo *root, int levels_needed, List *initial_rels)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    // 第1层</span><br><span class="line">    // 每个节点是一个基本关系(包含每个关系的所有访问方式)</span><br><span class="line">    root-&gt;join_rel_level[1] = initial_rels;  </span><br><span class="line">	</span><br><span class="line">	// 从第2层开始，求出每层的连接关系</span><br><span class="line">    for (lev = 2; lev &lt;= levels_needed; lev++)</span><br><span class="line">    &#123;</span><br><span class="line">        // 计算出第k层所有的中间关系</span><br><span class="line">        join_search_one_level(root, lev);</span><br><span class="line"></span><br><span class="line">        // 遍历lev上每个中间关系，找出最优的</span><br><span class="line">        foreach(lc, root-&gt;join_rel_level[lev])</span><br><span class="line">        &#123;</span><br><span class="line">            rel = (RelOptInfo *) lfirst(lc);</span><br><span class="line">            ......</span><br><span class="line"></span><br><span class="line">            // 查找本节点最优路径</span><br><span class="line">            set_cheapest(rel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	// 返回最终路径</span><br><span class="line">    rel = (RelOptInfo *) linitial(root-&gt;join_rel_level[levels_needed]);</span><br><span class="line">    root-&gt;join_rel_level = NULL;</span><br><span class="line">    return rel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="计算某层的中间关系">计算某层的中间关系</h4>
<p><strong>左右深树</strong></p>
<p><code>PlannerInfo</code>结构上的<code>join_rel_level</code>的用来存储关系，第1层是基本表关系，第2层到第N层是连接关系。</p>
<p>假设<code>A JOIN B JOIN C JOIN D</code>，<code>join_rel_level</code>如下：</p>
<ul>
<li><code>join_rel_level[1]</code>：(A)，(B)，(C)，(D)</li>
<li><code>join_rel_level[2]</code> ：连接第1层的表(满足JOIN约束)，得到(A⋈B)，(A⋈C)，(A⋈D)，(B⋈C)，(B⋈D)，(C⋈D)
<ul>
<li>(A⋈B) ：路径有(A JOIN B), (B JOIN A) 两种join顺序，<code>A merge-join B</code>, <code>A hash-join B</code>等不同的join方式。</li>
</ul></li>
<li><code>join_rel_level[3]</code>：用第1层和第2层的关系连接得到
<ul>
<li>左深树： ((A⋈B)⋈C)，((A⋈B)⋈D)，((A⋈C)⋈D)，((B⋈C)⋈D) ,等等</li>
<li>右深树：(A⋈(B⋈C)), (A⋈(B⋈D))等等</li>
</ul></li>
<li><code>join_rel_level[4]</code>：用第3层和第1层的关系进行连接
<ul>
<li>(((A⋈B)⋈C)⋈D), (A⋈(B⋈(C⋈D))) 等等</li>
<li>最终生成整个问题的最优路径。</li>
</ul></li>
</ul>
<p><strong>紧密树</strong></p>
<p>紧密树是由两个或多个连接关系之间再进行连接产生的关系。</p>
<p>所以，只有大于3层的关系才能产生紧密树，假如<code>A JOIN B JOIN C JOIN D JOIN E</code></p>
<ul>
<li><p>将第2层之间进行连接：((A⋈B)⋈(C⋈D)), ((A⋈D)⋈(B⋈C)), ((D⋈E)⋈(B⋈C)) 等</p>
<p>将第2层与第3层进行连接：((A⋈B)⋈(C⋈(D⋈E))),</p></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">// 计算出level的节点</span><br><span class="line">void join_search_one_level(PlannerInfo *root, int level)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    // 左深树和右深树 </span><br><span class="line">    // 遍历下一层的所有节点，将其与第1层节点进行JOIN</span><br><span class="line">    foreach(r, joinrels[level - 1])</span><br><span class="line">    &#123;</span><br><span class="line">        RelOptInfo *old_rel = (RelOptInfo *) lfirst(r);</span><br><span class="line"></span><br><span class="line">		// 符合连接约束</span><br><span class="line">        if (old_rel-&gt;joininfo != NIL || old_rel-&gt;has_eclass_joins ||</span><br><span class="line">            has_join_restriction(root, old_rel))</span><br><span class="line">        &#123;</span><br><span class="line">            ......</span><br><span class="line">            other_rels_list = joinrels[1];            // 第1层rels</span><br><span class="line">            other_rels = list_head(other_rels_list);  // 第1层的第一个rel或者当level=2时，第1层中r后面的rels，避免重复计算</span><br><span class="line">    	</span><br><span class="line">    	 	// 找出所有old_rel 和 other_rels_list的other_rels节点以后所有节点的 的连接 </span><br><span class="line">            make_rels_by_clause_joins(root, old_rel, other_rels_list, other_rels);</span><br><span class="line">        &#125;</span><br><span class="line">        else    // 没有join关系，做笛卡尔积</span><br><span class="line">        &#123;</span><br><span class="line">            make_rels_by_clauseless_joins(root, old_rel, joinrels[1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // bushy join，用第k层和level-k层连接，构成第level层关系; 而level在本函数的上层函数，</span><br><span class="line">    // 是从2到N从小到大动态变化的，这样，逐步对每层能够利用bushy连接方式构造连接树</span><br><span class="line">    for (k = 2;; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        int         other_level = level - k;</span><br><span class="line">        if (k &gt; other_level)</span><br><span class="line">            break;</span><br><span class="line">            </span><br><span class="line">		// 遍历第k层节点</span><br><span class="line">        foreach(r, joinrels[k])</span><br><span class="line">        &#123;</span><br><span class="line">            ......</span><br><span class="line">			</span><br><span class="line">			// 遍历level-k层节点</span><br><span class="line">            for_each_cell(r2, other_rels_list, other_rels)</span><br><span class="line">            &#123;</span><br><span class="line">                RelOptInfo *new_rel = (RelOptInfo *) lfirst(r2);</span><br><span class="line">                if (!bms_overlap(old_rel-&gt;relids, new_rel-&gt;relids))</span><br><span class="line">                &#123;</span><br><span class="line">                    if (have_relevant_joinclause(root, old_rel, new_rel) ||</span><br><span class="line">                        have_join_order_restriction(root, old_rel, new_rel))</span><br><span class="line">                    &#123;</span><br><span class="line">                        (void) make_join_rel(root, old_rel, new_rel);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果没有连接则做cartesian-product，</span><br><span class="line">    if (joinrels[level] == NIL)</span><br><span class="line">    &#123;</span><br><span class="line">    	......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// old_rel与 other_rels 之间生成连接关系</span><br><span class="line">static void make_rels_by_clause_joins(PlannerInfo *root, RelOptInfo *old_rel, List *other_rels_list, ListCell *other_rels)</span><br><span class="line">&#123;</span><br><span class="line">    ListCell   *l;</span><br><span class="line">    for_each_cell(l, other_rels_list, other_rels)</span><br><span class="line">    &#123;</span><br><span class="line">        RelOptInfo *other_rel = (RelOptInfo *) lfirst(l);</span><br><span class="line">        // 两个relis没有相同的relation，且有join关联性，且符合join顺序要求</span><br><span class="line">        if (!bms_overlap(old_rel-&gt;relids, other_rel-&gt;relids) &amp;&amp;</span><br><span class="line">            (have_relevant_joinclause(root, old_rel, other_rel) ||</span><br><span class="line">             have_join_order_restriction(root, old_rel, other_rel)))</span><br><span class="line">        &#123;</span><br><span class="line">            (void) make_join_rel(root, old_rel, other_rel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="创建关系">创建关系</h5>
<p><code>make_join_rel</code>用于创建一个新的连接关系并生成此连接关系的路径。</p>
<p>这个新关系的构成的每种方式就是一个路径，并保存于<code>RelOptInfo</code>的<code>pathlist</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RelOptInfo *make_join_rel(PlannerInfo *root, RelOptInfo *rel1, RelOptInfo *rel2)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    // 查找joinrel，如果没有则创建一个</span><br><span class="line">    joinrel = build_join_rel(root, joinrelids, rel1, rel2, sjinfo,  &amp;restrictlist);</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    // 生成路径</span><br><span class="line">    populate_joinrel_with_paths(root, rel1, rel2, joinrel, sjinfo, restrictlist);</span><br><span class="line">    </span><br><span class="line">    bms_free(joinrelids);</span><br><span class="line">    return joinrel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">RelOptInfo *build_join_rel(PlannerInfo *root, Relids joinrelids, RelOptInfo *outer_rel, RelOptInfo *inner_rel, SpecialJoinInfo *sjinfo, List **restrictlist_ptr)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    // 先查找此连接关系是否已经存在，</span><br><span class="line">    joinrel = find_join_rel(root, joinrelids);</span><br><span class="line">    if (joinrel)</span><br><span class="line">    &#123;</span><br><span class="line">        if (restrictlist_ptr)</span><br><span class="line">            *restrictlist_ptr = build_joinrel_restrictlist(root, joinrel, outer_rel, inner_rel);</span><br><span class="line">        return joinrel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	// 不存在，则初始化一个</span><br><span class="line">    joinrel = makeNode(RelOptInfo);</span><br><span class="line">    joinrel-&gt;reloptkind = RELOPT_JOINREL;</span><br><span class="line">    ......</span><br><span class="line">  </span><br><span class="line">    return joinrel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="生成路径">生成路径</h5>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">static void populate_joinrel_with_paths(PlannerInfo *root, RelOptInfo *rel1,</span><br><span class="line">							RelOptInfo *rel2, RelOptInfo *joinrel, SpecialJoinInfo *sjinfo, List *restrictlist)</span><br><span class="line">&#123;</span><br><span class="line">	switch (sjinfo-&gt;jointype)</span><br><span class="line">	&#123;</span><br><span class="line">		case JOIN_INNER:</span><br><span class="line">			......</span><br><span class="line">			// 生成 (rel1 JOIN rel2) and (rel2 JOIN rel1)两种路径</span><br><span class="line">			add_paths_to_joinrel(root, joinrel, rel1, rel2, JOIN_INNER, sjinfo, restrictlist);</span><br><span class="line">			add_paths_to_joinrel(root, joinrel, rel2, rel1, JOIN_INNER, sjinfo, restrictlist);</span><br><span class="line">			break;</span><br><span class="line">		case JOIN_LEFT:</span><br><span class="line">			......</span><br><span class="line">			// 对于left join：生成(rel1 left join rel2) and (rel2 right join rel1)两种路径</span><br><span class="line">			add_paths_to_joinrel(root, joinrel, rel1, rel2, JOIN_LEFT, sjinfo, restrictlist);</span><br><span class="line">			add_paths_to_joinrel(root, joinrel, rel2, rel1, JOIN_RIGHT, sjinfo, restrictlist);</span><br><span class="line">			break;</span><br><span class="line">		......</span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结">总结</h1>
<p>要枚举出查询树上所有路径，从中找出一个代价最小的路径，是个NP问题，计算成本是非常高昂的。而当查询树的关系(表、子查询等)较少时，可以使用动态规划算法枚举出所有的路径找出最优解，但是当关系较多时，枚举的计算成本是我们无法接收的，这时就需要使用一些折中方案，如贪心算法、遗传算法。遗传算法借鉴自然界“优胜劣汰”的法则对路径进化，从而能找出相对较优的查询路径。</p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>Donate comment here</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>Donate</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.png" alt="Ken WeChat Pay">
        <p>WeChat Pay</p>
      </div>
    

    

    

  </div>
</div>

      </div>
    

    
      <div>
        <footer class="post-footer"> 原有内容
<div>    
 
 
<ul class="post-copyright">
  <li class="post-copyright-author">
      <strong>本文作者：</strong>Ken
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="/2022/02/20/database-postgresql-path/" title="数据库路径选择理论与postgreSQL实现">2022/02/20/database-postgresql-path/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权： </strong>
    本站文章均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0 CN</a> 许可协议，请勿用于商业，转载注明出处！
  </li>
</ul>

</div>
      </footer></div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/database/" rel="tag"><i class="fa fa-tag"></i> database</a>
          
            <a href="/tags/PostgreSQL/" rel="tag"><i class="fa fa-tag"></i> PostgreSQL</a>
          
            <a href="/tags/genetic-algorithm/" rel="tag"><i class="fa fa-tag"></i> genetic algorithm</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/10/26/kubernetes_case/" rel="next" title="kubernetes雪崩了">
                <i class="fa fa-chevron-left"></i> kubernetes雪崩了
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="Ken">
            
              <p class="site-author-name" itemprop="name">Ken</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/ikenchina" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#路径选择理论"><span class="nav-number">2.</span> <span class="nav-text">路径选择理论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#join顺序的枚举"><span class="nav-number">2.1.</span> <span class="nav-text">JOIN顺序的枚举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#join方式的枚举"><span class="nav-number">2.2.</span> <span class="nav-text">JOIN方式的枚举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现方式"><span class="nav-number">2.3.</span> <span class="nav-text">实现方式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#postgresql实现"><span class="nav-number">3.</span> <span class="nav-text">postgreSQL实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#遗传算法"><span class="nav-number">3.1.</span> <span class="nav-text">遗传算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#算法"><span class="nav-number">3.1.1.</span> <span class="nav-text">算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现"><span class="nav-number">3.1.2.</span> <span class="nav-text">实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#主流程"><span class="nav-number">3.1.2.1.</span> <span class="nav-text">主流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#确定种群大小"><span class="nav-number">3.1.2.2.</span> <span class="nav-text">确定种群大小</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化种群"><span class="nav-number">3.1.2.3.</span> <span class="nav-text">初始化种群</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#适应度"><span class="nav-number">3.1.2.4.</span> <span class="nav-text">适应度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#选择染色体"><span class="nav-number">3.1.2.5.</span> <span class="nav-text">选择染色体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#杂交算法"><span class="nav-number">3.1.2.6.</span> <span class="nav-text">杂交算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#生成连接路径"><span class="nav-number">3.1.2.7.</span> <span class="nav-text">生成连接路径</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态规划"><span class="nav-number">3.2.</span> <span class="nav-text">动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#算法-1"><span class="nav-number">3.2.1.</span> <span class="nav-text">算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现-1"><span class="nav-number">3.2.2.</span> <span class="nav-text">实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#主流程-1"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">主流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#计算某层的中间关系"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">计算某层的中间关系</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#创建关系"><span class="nav-number">3.2.2.2.1.</span> <span class="nav-text">创建关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#生成路径"><span class="nav-number">3.2.2.2.2.</span> <span class="nav-text">生成路径</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">4.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ken</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>








        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>访问
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'p5Hbkh5aS4MFndlbI9msQ0OF-gzGzoHsz',
        appKey: 'gAYKVuvBLmJ2d8V0RrxlrYyF',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  


  

  

</body>
</html>
